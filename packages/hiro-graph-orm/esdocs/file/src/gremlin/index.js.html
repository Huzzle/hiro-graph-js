<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/gremlin/index.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">codec</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBool">createBool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEnum">createEnum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createCodec">createCodec</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">context</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context/context_entity.doc.js~Context$Entity.html">Context$Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context/index.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">gremlin</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/gremlin/index.js~GremlinQueryBuilder.html">GremlinQueryBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-queryBuilder">queryBuilder</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">lucene</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseLucene">parseLucene</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">schema</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/schema/index.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEntity">createEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validate">validate</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">types</div><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec">Codec</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GremlinBranch">GremlinBranch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-LuceneQuery">LuceneQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-OneOrMoreVertices">OneOrMoreVertices</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/arago/js-graphit-client/blob/master/src/connection.js">Connection</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vertex</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vertex/graph.js~GraphVertex.html">GraphVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vertex/index.js~Vertex.html">Vertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createVertex">createVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isVertex">isVertex</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/gremlin/index.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 *  Schema aware Gremlin wrapper.
 */
import { gremlin } from &quot;../context/graph&quot;;

//This is a placeholder until &quot;parse&quot; is designed and implemented
/**
 *  @ignore - no docs.
 */
export default function parseGremlin(/*query = {}, entity*/) {
    throw new Error(&quot;@TODO: need to figure out a good API for schema aware gremlin queries. Then we can implement&quot;);
    //Not sure this is needed with entity.encode();
}

/**
 *  Create a new query builder
 *
 *  @param {string|GremlinQueryBuilder} initialQuery - a starting point query
 *  @param {Context} context - a {@link Context} object, allowing this gremlin query to `execute` itself.
 *  @return {GremlinQueryBuilder} - a new query builder
 */
export function queryBuilder(initialQuery, context) {
    return new GremlinQueryBuilder(initialQuery, context);
}

/**
 *  A simple gremlin query builder object.
 *
 *  Provides a convenience for having to produce the queries by hand,
 *  and escapes the terms correctly.
 */
export class GremlinQueryBuilder {

    /**
     *  @param GremlinQueryBuilder} initialQuery - An initial query to base this one on.
     *  @param {?Context} context - a {@link Context} object, allowing this gremlin query to `execute` itself.
     *  @return {GremlinQueryBuilder} - a new query builder
     */
    constructor(initialQuery = false, context) {
        this._ctx = context;
        this._stack = [];
        this._query = false;
        if (initialQuery) {
            this._stack.push(initialQuery);
            this._query = initialQuery;
        }
    }

    /**
     * Execute a gremlin query against the internal context.
     *
     * Will throw an error if no context is present on this instance
     *
     *  @param {string} rootVertexId - the Root vertex to initiate this query
     *  @param {object} [options={}] - further options to pass to the GraphIT connection
     *  @retruen {Promise&lt;any&gt;} - A promise for the results, which could be anything
     */
    execute(rootVertexId, options = {}) {
        return gremlin(this._ctx, rootVertexId, this.toString(), options);
    }

    /**
     *  Execute the query in the given context
     *
     *  Similiar to `.execute` but uses the give context, not the internal one.
     *
     *  @param {Context} ctx - the Graph Context to use for this query
     *  @param {string} rootVertexId - the Root vertex to initiate this query
     *  @param {object} [options={}] - further options to pass to the GraphIT connection
     *  @retruen {Promise&lt;any&gt;} - A promise for the results, which could be anything
     */
    executeInContext(ctx, rootVertexId, options = {}) {
        return gremlin(ctx, rootVertexId, this.toString(), options);
    }

    /**
     *  Query along a Schema-defined Relation
     *
     *  @param {string} type - the Schema type name for the entity the relation belongs to
     *  @param {Array&lt;string&gt;} relations - the names of the relations to generate a gremlin query for
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    relation(type, relations) {
        if (!this._ctx) {
            throw new Error(&quot;Cannot use gremlin `relation` without context&quot;);
        }
        return this._ctx[type].relationQuery(relations)(this);
    }

    /**
     * Turns the query into a string to send to GraphIT
     *
     * We cache the string form, so you *must* always use &quot;raw&quot; to update the stack
     * even from inside the class methods.
     *
     *  @return {string} the string representation of the query
     */
    toString() {
        if (this._query === false) {
            this._query = this._stack.filter(Boolean).join(&quot;.&quot;);
        }
        return this._query;
    }

    /**
     *  Push a raw query segment onto the internal stack
     *
     *  This is used by all internal methods and adds data
     *  to the current query.
     *
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    raw(query) {
        this._stack.push(query);
        this._query = false;
        return this;
    }

    /**
     *  Append to the last chunk in the stack,
     *
     *  This is used for the very rare instances where you
     *  need to add directly to the last element in the stack
     *  rather than adding a new element (which would be `.` seperated)
     *
     *  The example is a limit clause which appends `[0..1]` directly to
     *  the current pipeline.
     *
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    append(query) {
        const chunk = this._stack.pop() + query;
        return this.raw(chunk);
    }

    /**
     *  Apply one or more transforms to the query
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#transform-1
     *
     *  @param {object.&lt;string, GremlinBranch&gt;|Array&lt;GremlinBranch&gt;} transforms - the transformations to make
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    transform(transforms) {
        let branches;
        const brancher = createBrancher(&quot;it&quot;, this._ctx);
        if (Array.isArray(transforms)) {
            //closure to remove the &quot;index&quot; argument
            branches = transforms.map(value =&gt; brancher(value));
        } else {
            branches = Object.keys(transforms).map(key =&gt; brancher(transforms[key], key));
        }
        return this.raw(`transform{[${branches.join(&quot;,&quot;)}]}`);
    }

    /**
     *  Split the pipeline into multiple (and merge back)
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#copysplit
     *
     *  @param {Array&lt;GremlinBranch&gt;} paths - the transformations to make
     *  @param {string} [mergeType=fairMerge] - the method of merging the results.
                            either `fairMerge` which is one of each branch in turn
                            or `exhaustMerge` which exhausts each branch in turn
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    copySplit(paths, mergeType = &quot;fairMerge&quot;) {
        if (mergeType !== &quot;fairMerge&quot; &amp;&amp; mergeType !== &quot;exhaustMerge&quot;) {
            throw new Error(&quot;invalid copySplit merge. should be `fairMerge` or `exhaustMerge`&quot;);
        }
        const brancher = createBrancher(&quot;_()&quot;, this._ctx);
        const branches = paths.map(value =&gt; brancher(value));
        return this.raw(`copySplit(${branches.join(&quot;,&quot;)}).${mergeType}`);
    }

    /**
     *  Or conditions are handle with a branching method.
     *
     *  Each condition is considered and any one pass means the
     *  object continues through the pipeline.
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#or
     *
     *  @param {Array&lt;GremlinBranch&gt;} conditions - the array of possible conditions
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    or(conditions) {
        const brancher = createBrancher(&quot;_()&quot;, this._ctx);
        const branches = conditions.map(value =&gt; brancher(value));
        return this.raw(`or(${branches.join(&quot;,&quot;)})`);
    }

    /**
     *  Apply a deduplication filter
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#dedup
     *
     *  @param {string} [prop=ogit/_id] - the property to perform the deduplication on.
                            You will almost always want the default (`ogit/_id`).
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    dedup(prop = &quot;ogit/_id&quot;) {
        return this.raw(`dedup{it.getProperty(${quote(prop)})}`);
    }

    /**
     *  Restrict results to a subset of the pipeline
     *
     *  NB. `start` zero based an inclusive, `finish` is absolute (not relative to start) and inclusive.
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#ij
     *
     *  @param {number} start - where to begin from
     *  @param {number} finish - where to end
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    limit(start, finish) {
         //this needs to be merged directly onto the last element of the query!
        //but only after we have provided the clause to filter deleted elements.
        //otherwise this limiting will no do what we expect.
        //@TODO check in GraphIT as to whether this is still needed...
        this.hasNot(&quot;ogit/_is-deleted&quot;, true);
        //now append the limit
        return this.append(`[${start}..${finish}]`);
    }

    /**
     *  Re-order the pipeline
     *
     *  Note that in GraphIT almost everything is a string, so ordering is
     *  lexical. (most codecs created by {@link createCodec} respect lexical ordering)
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#order
     *
     *  @param {string} prop - the property to order by
     *  @param {string} dir - the direction of the ordering, `asc` or `desc`.
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    order(prop, dir = &quot;desc&quot;) {
        const isAsc = dir === &quot;asc&quot;;
        const getProp = `.getProperty(${quote(prop)})`;
        const [first, second] = isAsc ? [&quot;a&quot;, &quot;b&quot;] : [&quot;b&quot;, &quot;a&quot;];
        return this.raw(`order{it.${first}${getProp} &lt;=&gt; it.${second}${getProp}}`);
    }

    /**
     *  Filter the pipeline with a closure.
     *
     *  **NB there is currently no validation of the input**
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#filter-1
     *
     *  @param {string} condition - the string version of the closure for filtering the pipeline
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    filter(condition) {
        //NB no validation is done here!
        //perhap we could improve with
        // filter(subjectGremlinQuery, comparator, object)
        // e.g filter(_ =&gt; _.getProperty(&quot;age&quot;), &quot;&gt;&quot;, 29);
        return this.raw(`filter{${condition}}`);
    }

    /**
     *  Shorthand for a transform that adds a static temporary property to each result in the pipeline
     *
     *  @param {string} name - the temporary property name (must start with `$_`)
     *  @param {string} value - the static value to add to each result
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    addTempProp(name, value) {
        ensureTemporaryPropNameOK(name);
        this.raw(`transform{it.${name}=${quote(value)};it}`);
    }
    /**
     *  Shorthand for a transform that adds a dynamic temporary property to each result in the pipeline
     *
     *  @param {string} name - the temporary property name (must start with `$_`)
     *  @param {string|GremlinBranch} query - the query to produce a value to add to each result.
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    addComputedProp(name, query) {
        ensureTemporaryPropNameOK(name);
        const subQuery = createBrancher(&quot;it&quot;)(query);
        return this.raw(`transform{it.${name}=${subQuery};it}`);
    }

    /**
     *  Group results by given property&apos;s value
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#groupby
     *
     *  @param {string} groupingProp - the property to group by.
     *  @param {string} resultProp - the property to use in the groups - probably `ogit/_id`
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    groupBy(groupingProp, resultProp = false) {
        const prop = (groupingProp === &quot;label&quot;) ? groupingProp : `getProperty(${quote(groupingProp)})`;
        const resultStanza = resultProp ? `it.getProperty(${quote(resultProp)})` : &quot;it&quot;;
        return this.raw(`groupBy{it.${prop}}{${resultStanza}}.cap`);
    }

    /**
     *  Count results grouped by given property&apos;s value
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#groupby
     *
     *  @param {string} groupingProp - the property to group by.
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    groupCount(groupingProp) {
        const prop = (groupingProp === &quot;label&quot;) ? groupingProp : `getProperty(${quote(groupingProp)})`;
        return this.raw(`groupCount{it.${prop}}.cap`);
    }

    /**
     *  Traverse to incoming edges
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#ine
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    inE(...args) {
        return this.raw(methodCall(&quot;inE&quot;, args));
    }

    /**
     *  Traverse to outbound edges
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#oute
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    outE(...args) {
        return this.raw(methodCall(&quot;outE&quot;, args));
    }

    /**
     *  Traverse to edges in both directions
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#bothe
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    bothE(...args) {
        return this.raw(methodCall(&quot;bothE&quot;, args));
    }

    /**
     *  Traverse to incoming vertices
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#inv
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    inV(...args) {
        return this.raw(methodCall(&quot;inV&quot;, args));
    }

    /**
     *  Traverse to outbound vertices
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#outv
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    outV(...args) {
        return this.raw(methodCall(&quot;outV&quot;, args));
    }

    /**
     *  Traverse to vertices in both directions
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#bothv
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    bothV(...args) {
        return this.raw(methodCall(&quot;bothV&quot;, args));
    }

    /**
     *  Traverse to vertices along inbound edges
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#in
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    in(...args) {
        return this.raw(methodCall(&quot;in&quot;, args));
    }
    /**
     *  Traverse to vertices along outbound edges
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#out
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    out(...args) {
        return this.raw(methodCall(&quot;out&quot;, args));
    }

    /**
     *  Traverse to vertices along edges in either direction
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#both
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    both(...args) {
        return this.raw(methodCall(&quot;both&quot;, args));
    }

    /**
     *  pluck a property value from each element in the pipeline
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#key
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    getProperty(...args) {
        return this.raw(methodCall(&quot;getProperty&quot;, args));
    }

    /**
     *  Count the results in the pipeline
     *
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    count(...args) {
        return this.raw(methodCall(&quot;count&quot;, args));
    }

    /**
     *  Mark a pipeline position for later back-filtering
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#as
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    as(...args) {
        return this.raw(methodCall(&quot;as&quot;, args));
    }

    /**
     *  Back-filter to a named step or by a number of steps.
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#back
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    back(...args) {
        return this.raw(methodCall(&quot;back&quot;, args));
    }

    /**
     *  Randomize pipeline output order
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#shuffle
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    shuffle(...args) {
        return this.raw(methodCall(&quot;shuffle&quot;, args));
    }

    /**
     *  Filter the pipeline to object which match the pattern
     *
     *  The argument here can be an object of &quot;prop&quot; =&gt; &quot;value&quot; (which you
     *  can encode with a {@see Codec})
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#has
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    has(...args) {
        return objectMethodCall(this, &quot;has&quot;, args);
    }

    /**
     *  Filter the pipeline to object which **don&apos;t** match the pattern
     *
     *  The argument here can be an object of &quot;prop&quot; =&gt; &quot;value&quot; (which you
     *  can encode with a {@see Codec})
     *
     *  @see http://gremlindocs.spmallette.documentup.com/#hasnot
     *  @return {GremlinQueryBuilder} - the same object (chainable)
     */
    hasNot(...args) {
        return objectMethodCall(this, &quot;hasNot&quot;, args);
    }
}

//helper to validate temporary property name
const ensureTemporaryPropNameOK = name =&gt; {
    if (name.indexOf(&quot;$_&quot;) !== 0) {
        throw new Error(`Gremlin temporary properties must start with $_, given: ${name}`);
    }
};

//creates a branched structure with subQueries
const createBrancher = (prefix, ctx) =&gt; (value, key = false) =&gt; {
    const subQuery = new GremlinQueryBuilder(prefix, ctx);
    //if a string, assume a fixed query
    if (typeof value === &quot;string&quot;) {
        subQuery.raw(value);
    } else {
        value(subQuery);
    }
    return (key ? key + &quot;:&quot; : &quot;&quot;) + subQuery;
};

//quote a value for use in a gremlin function argument.
const quote = value =&gt; `&quot;${value.replace(/&quot;/g, `\\&quot;`).replace(/\$/g, `\\$`)}&quot;`;

const formatArgs = args =&gt; args.map(value =&gt; {
    if (value === true || value === false) {
        //don&apos;t quote;
        return value ? &quot;true&quot; : &quot;false&quot;;
    }
    if (Array.isArray(value)) {
        //OK, an array of values need quoting and adding surrounded by
        //square brackets
        return `[${formatArgs(value).join(&quot;,&quot;)}]`;
    }
    //after this cast to string
    const str = &quot;&quot; + value;

    if (/^T\.[a-z]+/.test(str)) {
        //this is an identifier used for comparison operators.
        //do not quote.
        return str;
    }
    if (/^[0-9]+(\.[0-9]*)?[lf]?$/.test(str)) {
        //this is a java int/long/float, return as is.
        //NB this is not the only way to denote this, but
        //the only format *we* accept.
        return str;
    }
    //otherwise just quote.
    return quote(str);
});

//a simple method call to string.
const methodCall = (method, args = []) =&gt; {
    return `${method}(${formatArgs(args).join(&quot;,&quot;)})`;
};

const objectMethodCall = (instance, method, args = []) =&gt; {
    const first = args[0];
    if (typeof first === &quot;object&quot;) {
        Object.keys(first).forEach(key =&gt; {
            //only single arguments in this form.
            instance.raw(methodCall(method, [key, first[key]]));
        });
        return instance;
    }
    return instance.raw(methodCall(method, args));
};
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
