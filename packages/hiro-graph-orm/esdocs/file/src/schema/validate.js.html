<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/schema/validate.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">codec</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBool">createBool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEnum">createEnum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createCodec">createCodec</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">context</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context/context_entity.doc.js~Context$Entity.html">Context$Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context/index.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">gremlin</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/gremlin/index.js~GremlinQueryBuilder.html">GremlinQueryBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-queryBuilder">queryBuilder</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">lucene</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseLucene">parseLucene</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">schema</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/schema/index.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEntity">createEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validate">validate</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">types</div><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec">Codec</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GremlinBranch">GremlinBranch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-LuceneQuery">LuceneQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-OneOrMoreVertices">OneOrMoreVertices</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/arago/js-graphit-client/blob/master/src/connection.js">Connection</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vertex</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vertex/graph.js~GraphVertex.html">GraphVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vertex/index.js~Vertex.html">Vertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createVertex">createVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isVertex">isVertex</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/schema/validate.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { statSync, readFileSync, readdirSync } from &quot;fs&quot;;
import { join } from &quot;path&quot;;
import { safeLoad } from &quot;js-yaml&quot;;

import { $dangerouslyGetProps, $dangerouslyGetRelations } from &quot;./entity&quot;;

/**
 *  Validate a schema against an OGIT ontology
 *
 *  This allows a schema to validate itself against a given YAML OGIT
 *  ontology definition, either as a single file or multiple (e.g. a cloned repo)
 *
 *  This is important as it allows our schema definitions to remain correct with
 *  respect to the ontology that your GraphIT uses.
 *
 *  This is a `node` only piece of functionality and is intended to run as part of a linting
 *  or testing phase.
 *
 *  @param {Schema} schema - the schema to check
 *  @param {string} ontologyLocation - a path to an ontology file or repo.
 *  @return {object} result
 *  @property {number} errors - the number of problems found
 *  @property {object.&lt;string,Array&lt;string&gt;&gt;} detail - the errors grouped by entity name
 */
export default function validate(schema, ontologyLocation) {
    let ontology;
    try {
        ontology = load(ontologyLocation);
    } catch (e) {
        return {
            errors: 1,
            loadOntologyFail: e.message
        };
    }
    //schema.names has the application name of each entity.
    return schema.names
        .map(name =&gt; schema.get(name))
        .reduce((output, entity) =&gt; {
            const errors = validateEntity(entity, ontology);
            if (errors.length) {
                output.errors += errors.length;
                output.detail[entity.name] = errors;
            }
            return output;
        }, { errors: 0, detail: {} });
}

//load an ontology.
//location should be a path
//if a file, load just that.
//if a dir, recurse and load all files.
const load = (location, ontology = emptyOntology()) =&gt; {
    const stat = statSync(location);
    if (stat.isDirectory()) {
        readdirSync(location).forEach(entry =&gt; {
            const fullPath = join(location, entry);
            load(fullPath, ontology);
        });
    } else if (stat.isFile() &amp;&amp; isYamlFile(location)) {
        const data = safeLoad(readFileSync(location, &quot;utf8&quot;), { onWarning: () =&gt; {} });
        //data should be an array
        if (Array.isArray(data)) {
            data.forEach(object =&gt; {
                let type, item;
                switch (true) {
                    case (&quot;Entity&quot; in object):
                        type = &quot;entities&quot;;
                        item = object.Entity;
                        break;
                    // we don&apos;t actually care about this...
                    // case (&quot;Attribute&quot; in object):
                    //     type = &quot;attributes&quot;;
                    //     item = object.Attribute;
                    //     break;
                    case (&quot;Verb&quot; in object):
                        type = &quot;verbs&quot;;
                        item = object.Verb;
                        break;
                    default:
                        //no default
                        return;
                }
                item.__sourcefile__ = location;
                item.ogit = depurl(item.id);
                ontology[type][item.ogit] = item;
            });
        }
    }
    return ontology;
};

const depurl = name =&gt; name.replace(&quot;http://www.purl.org/&quot;, &quot;&quot;);

const isYamlFile = file =&gt; /\.ya?ml$/.test(file);

const emptyOntology = () =&gt; ({
    entities: {},
    //attributes: {},
    verbs: {}
});

// now the tricky one, validate an entity against an ontology.
//
// The rules are:
//
//  - the entity.ogit name MUST exist in the ontology
//  - any *mandatory* fields in ontology MUST be *required* here.
//  - any required/optional fields using *non-free* attributes MUST reference valid attributes in ontology
//  - any relations must be valid:
//    - all hops have valid verbs for the entities and directions
//    - any filters must be on valid properties
function validateEntity(appEntity, { entities, verbs }) {
    if (appEntity.ogit in entities === false) {
        return [`Entity (${appEntity.name}) does not exist in Ontology as &apos;${appEntity.ogit}&apos;`];
    }
    const ogitEntity = entities[appEntity.ogit];
    const errors = [];

    //check mandatory attributes
    if (ogitEntity.attributes.mandatory) {
        ogitEntity.attributes.mandatory.map(depurl).forEach(attr =&gt; {
            //invalid if not in appEntity.required.
            const prop = appEntity.prop(attr);
            if (!prop) {
                errors.push(`Ontology mandatory field (${attr}) not defined in Entity (${appEntity.name})`);
            } else if (!prop.required) {
                errors.push(`Ontology mandatory field (${attr}) not listed as &apos;required&apos; in Entity (${appEntity.name})`);
            }
        }, []);
    }

    //check non-free attributes valid
    //first get the list of attributes in this ontology item
    const validAttributes = getValidAttributes(ogitEntity);

    appEntity[$dangerouslyGetProps]()
        //we are checking non-free attributes. so we remove the free ones
        //and also remove the &quot;ogit&quot; internal attributes
        .filter(prop =&gt; prop.src.charAt(0) !== &quot;/&quot; &amp;&amp; !/^ogit\/_/.test(prop.src))
        .filter(prop =&gt; !validAttributes[prop.src]) //remove valid ones.
        .forEach(invalidProp =&gt; {
            //all the remaining are invalid
            errors.push(`Entity ${invalidProp.required ? &quot;required&quot; : &quot;optional&quot;} property (${invalidProp.dst}) does not reference an available attribute in Ontology (${invalidProp.src})`);
        });

    //now check relations.
    const relations = appEntity[$dangerouslyGetRelations]();

    Object.keys(relations).forEach(alias =&gt; {
        let startNodes = [appEntity.ogit];
        let broken = false;
        relations[alias].hops.forEach((hop, i) =&gt; {
            if (broken) {
                return;
            }
            const { direction, verb, filter, vertices } = hop;
            //first check the verb exists.
            if (verb in verbs === false) {
                errors.push(`Relation (${alias}) invalid at hop (${i + 1}): Verb (${verb}) does not exist in ontology.`);
                broken = false;
                return;
            }
            const connections = getValidConnections(verbs[verb]);
            vertices.forEach(endNode =&gt; {
                startNodes.forEach(startNode =&gt; {
                    const key = direction === &quot;out&quot; ? [startNode, endNode] : [endNode, startNode];
                    if (
                        !connections[key.join()]) {
                        errors.push(`Relation (${alias}) invalid at hop (${i + 1}): Connection from &apos;${key[0]} --&gt; ${verb} -&gt; ${key[1]}&apos; not allowed.`);
                    }
                });
                // also check the endNodes for filter props if filter exists and has
                // non-free attributes in it.
                if (filter) {
                    const endDefinition = entities[endNode];
                    const validEndAttributes = getValidAttributes(endDefinition);
                    Object.keys(filter)
                        //remove any free or internal props.
                        .filter(prop =&gt; prop.src.charAt(0) !== &quot;/&quot; || !/^ogit\/_/.test(prop.src))
                        //remove valid props.
                        .filter(prop =&gt; !validEndAttributes[prop])
                        //the rest are errors
                        .forEach(prop =&gt; errors.push(`Relation (${alias}) invalid at hop (${i + 1}): filter contains invalid prop (${prop}) for Entity (${endNode})`));
                }
            });
            //now switch the start nodes and let it repeat.
            startNodes = vertices;
        });
    });
    return errors;
}

const validAttributeCache = {};
function getValidAttributes(entity) {
    if (entity.ogit in validAttributeCache === false) {
        validAttributeCache[entity.ogit] = (entity.attributes.mandatory || [])
            .concat(entity.attributes.optional || [])
            .map(depurl)
            .reduce((valid, attr) =&gt; (valid[attr] = true, valid), {});
    }
    return validAttributeCache[entity.ogit];
}

const validConnectionsCache = {};
function getValidConnections(verb) {
    if (verb.ogit in validConnectionsCache === false) {
        validConnectionsCache[verb.ogit] = (verb.allowed || [])
            .map(({ from, to }) =&gt; [depurl(from), depurl(to)].join())
            .reduce((valid, attr) =&gt; (valid[attr] = true, valid), {});
    }
    return validConnectionsCache[verb.ogit];
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
