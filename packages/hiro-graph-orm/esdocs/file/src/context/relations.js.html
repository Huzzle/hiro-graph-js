<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/context/relations.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">codec</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createBool">createBool</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEnum">createEnum</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createCodec">createCodec</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">context</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context/context_entity.doc.js~Context$Entity.html">Context$Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/context/index.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">gremlin</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/gremlin/index.js~GremlinQueryBuilder.html">GremlinQueryBuilder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-queryBuilder">queryBuilder</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">lucene</div><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseLucene">parseLucene</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">schema</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/schema/index.js~Schema.html">Schema</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEntity">createEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-validate">validate</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">types</div><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Codec">Codec</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-GremlinBranch">GremlinBranch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-LuceneQuery">LuceneQuery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-OneOrMoreVertices">OneOrMoreVertices</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-external">E</span><span data-ice="name"><span><a href="https://github.com/arago/js-graphit-client/blob/master/src/connection.js">Connection</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">vertex</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vertex/graph.js~GraphVertex.html">GraphVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/vertex/index.js~Vertex.html">Vertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createVertex">createVertex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isVertex">isVertex</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/context/relations.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 *  This is where the crazy queries for relation data are handled.
 */
import { mapPromiseIfArray } from &quot;../utils&quot;;
import { vertexize } from &quot;./graph&quot;;

function createRelationMap(relations, keyFn = () =&gt; []) {
    return relations.reduce((obj, rel) =&gt; (obj[rel] = keyFn(rel), obj), {});
}

//returns an object { relation: [ obj, ... ] }
/**
 * @ignore - we don&apos;t need docs about this. they are internal exports
 */
export function fetchVertices(ctx, entity) {
    return relationQuery(ctx, entity, (relations, gremlin, options) =&gt; {
        //get the nodes as well
        const query = gremlin.copySplit([
            //this is the edge map
            _ =&gt; _.groupBy(&quot;$_alias&quot;, &quot;ogit/_id&quot;),
            //and this is all the nodes
            _ =&gt; _.dedup()
        ]);
        if (options.returnQuery) {
            return query;
        }
        return mapPromiseIfArray(vertex =&gt; {
            return query.executeInContext(ctx, vertex._id, Object.assign({ raw: true }, options))
                .then(([edgeMap, ...raw]) =&gt; {
                    //patch them together again
                    return vertexize(ctx)(raw)
                        .then(vertices =&gt; {
                            const vertexMap = vertices.reduce((o, v) =&gt; (o[v._id] = v, o), {});
                            return createRelationMap(relations, key =&gt; {
                                if (edgeMap[key]) {
                                    return edgeMap[key].map(id =&gt; vertexMap[id]);
                                }
                                return [];
                            });
                        });
                });
        });
    });
}

//returns an object { relation: [ id, id, ... ] }
/**
 * @ignore - we don&apos;t need docs about this. they are internal exports
 */
export function fetchIds(ctx, entity) {
    return relationQuery(ctx, entity, (relations, gremlin, options) =&gt; {
        //count the aliases.
        const query = gremlin.groupBy(&quot;$_alias&quot;, &quot;ogit/_id&quot;);
        if (options.returnQuery) {
            return query;
        }
        return mapPromiseIfArray(vertex =&gt; {
            return query
                .executeInContext(ctx, vertex._id, Object.assign({ raw: true }, options))
                .then(([info]) =&gt; createRelationMap(relations, key =&gt; info[key] || []));
        });
    });
}

//returns an object { relation: X }
/**
 * @ignore - we don&apos;t need docs about this. they are internal exports
 */
export function fetchCount(ctx, entity) {
    return relationQuery(ctx, entity, (relations, gremlin, options) =&gt; {
        //count the aliases.
        const query = gremlin.groupBy(&quot;$_alias&quot;);
        return mapPromiseIfArray(vertex =&gt; {
            return query
                .executeInContext(ctx, vertex._id, Object.assign({ raw: true }, options))
                .then(([info]) =&gt; createRelationMap(relations, key =&gt; info[key] || 0));
        });
    });
}

//expose this to allow getting the query for a relation
/**
 * @ignore - we don&apos;t need docs about this. they are internal exports
 */
export function getRelationQuery(entity, relation, options = {}) {
    return relationQueryGenerator(entity, options)(relation);
}

//creates a relation query and returns it.
/**
 * @ignore - we don&apos;t need docs about this. they are internal exports
 */
function relationQuery(ctx, entity, finaliser) {
    const getQuery = relationQueryGenerator(entity, { withAlias: &quot;$_alias&quot; });
    return (relations, options = {}) =&gt; {
        const queries = relations.map(getQuery);

        //now we have an array.
        const gremlin = ctx.gremlin();
        if (queries.length === 1) {
            queries[0](gremlin); //apply directly.
        } else {
            gremlin.copySplit(queries);
        }
        //finish up indiviually
        return finaliser(relations, gremlin, options);
    };
}

// The complex one (although simplified and generalised from the TabTab original...)
// This function creates a gremlin query that traverses according to the defined
// relation in the schema.
/**
 * @ignore - we don&apos;t need docs about this. they are internal exports
 */
export function relationQueryGenerator(entity, { withAlias = false }) {
    return relation =&gt; {
        const { alias, hops } = entity.relation(relation);
        return gremlin =&gt; {
            hops.forEach(({ verb, direction, filter, vertices }) =&gt; {
                const inbound = direction === &quot;in&quot;;
                const firstEdge = inbound ? &quot;inE&quot; : &quot;outE&quot;;
                const secondEdge = inbound ? &quot;outV&quot; : &quot;inV&quot;;
                const edgeTypeProp = inbound ? &quot;ogit/_out-type&quot; : &quot;ogit/_in-type&quot;;

                //traverse the edge by verb label.
                gremlin[firstEdge](verb);

                //now there are three paths dependent on whether there is zero, only one or multiple vertex type(s).
                //if so we can optimise.
                switch (true) {
                    case (vertices.length === 0):
                        //no node type specified, could be anything.
                        break;
                    case (vertices.length === 1):
                        //only a single vertextype.
                        gremlin.has(edgeTypeProp, vertices[0]);
                        break;
                    default:
                        //many possible nodes, we use T.in to filter.
                        gremlin.has(edgeTypeProp, &quot;T.in&quot;, vertices);
                }

                //now out to the vertices
                gremlin[secondEdge]();

                //now we filter if there is one.
                if (filter) {
                    gremlin.has(filter);
                }
            });

            //now we have the vertices, if we were going to add an alias, here it comes.
            if (withAlias) {
                gremlin.addTempProp(withAlias, alias);
            }

            return gremlin;
        };
    };
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
