[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/bin/validate-schema-against-ontology.js",
    "memberof": null,
    "longname": "src/bin/validate-schema-against-ontology.js",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "content": "#!/usr/bin/env node\n/**\n *  Validate a schema against an ontology\n *\n *  Usage:\n *      validate <module_path> <ontology_path>\n *\n *  `module_path` should be a path to a javascript module that exports\n *  the schema definitions you want to validate (or a schema object)\n *\n *  `ontology_path` should be the path to you ontology, either a file or a base directory.\n */\nconst [modulePath, ontologyPath] = process.argv.slice(2, 4);\nimport { join } from \"path\";\nimport Schema from \"../schema\";\nimport validate from \"../schema/validate\";\n\nlet module = require(join(process.cwd(), modulePath).replace(/\\/$/, \"\"));\nif (module.__esModule) {\n    module = module.default;\n}\n\nif (module instanceof Schema === false) {\n    module = new Schema(module);\n}\n\nconst result = validate(module, ontologyPath);\n\nconsole.log(result);\nprocess.exit(result.errors);\n"
  },
  {
    "__docId__": 1,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "modulePath",
    "memberof": "src/bin/validate-schema-against-ontology.js",
    "longname": "src/bin/validate-schema-against-ontology.js~modulePath",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/bin/validate-schema-against-ontology",
    "importStyle": null,
    "description": " Validate a schema against an ontology\n\n Usage:\n     validate <module_path> <ontology_path>\n\n `module_path` should be a path to a javascript module that exports\n the schema definitions you want to validate (or a schema object)\n\n `ontology_path` should be the path to you ontology, either a file or a base directory.",
    "lineNumber": 13,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 2,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "module",
    "memberof": "src/bin/validate-schema-against-ontology.js",
    "longname": "src/bin/validate-schema-against-ontology.js~module",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/bin/validate-schema-against-ontology",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "result",
    "memberof": "src/bin/validate-schema-against-ontology.js",
    "longname": "src/bin/validate-schema-against-ontology.js~result",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/bin/validate-schema-against-ontology",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/_number_utils.js",
    "memberof": null,
    "longname": "src/codec/_number_utils.js",
    "access": null,
    "description": null,
    "lineNumber": 9,
    "content": "/**\n *  Extracting Number functions to a common module\n *\n *  Numbers are tricky because we want to ensure that they are lexically sortable.\n * @ignore\n */\n\n//see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n//these should lexically sort with negative lowest and be only one character.\n//unfortunately \"-\" and \"+\" do not sort this way... :(\nconst NEGATIVE_MARKER = \"n\";\nconst POSITIVE_MARKER = \"p\";\n\n//this is how long out padding should be\nconst PAD_LENGTH = (\"\" + MAX_SAFE_INTEGER).length;\n\n//the user should pass an integer. We truncate if not.\n//also, if `signed` and the number is negative,\n// we subtract from MAX_SAFE_INTEGER to ensure the correct sort order.\nconst integerMagnitude = (number = NaN, { signed = false } = {}) => {\n    const n = Number(number);\n    if (!isFinite(n) || isNaN(n)) {\n        return 0;\n    }\n    let mag = Math.min(Math.floor(Math.abs(number)), MAX_SAFE_INTEGER);\n    if (mag > MAX_SAFE_INTEGER) {\n        mag = MAX_SAFE_INTEGER;\n    }\n    return (signed && number < 0) ? (MAX_SAFE_INTEGER - mag) : mag;\n};\n\n//left pad an integer for sorting.\nconst lexicalPad = (integer, prefix = \"\") => {\n    const string = \"\" + integer;\n    const zeroes = PAD_LENGTH - string.length;\n    return `${prefix}${\"0\".repeat(zeroes)}${string}`;\n};\n\n/**\n * @ignore\n */\nexport const encodeUInt = number => lexicalPad(integerMagnitude(number));\n\n/**\n * @ignore\n */\nexport const encodeInt = number => {\n    const prefix = number < 0 ? NEGATIVE_MARKER : POSITIVE_MARKER;\n    return lexicalPad(integerMagnitude(number, { signed: true }), prefix);\n};\n\n\n/**\n * decode a string expecting a plain unsigned int.\n * @ignore\n */\nexport const decodeUInt = string => {\n    //first we should check if this is a signed int representation,\n    //and discard sign (for ease of compatibility)\n    return Math.abs(decodeInt(string));\n};\n\n/**\n * Decode a signed number string\n * @ignore\n */\nexport const decodeInt = string => {\n    let digits = string.slice(1);\n    const sign = string[0];\n    if (sign !== POSITIVE_MARKER && sign !== NEGATIVE_MARKER) {\n        //no marker assume positive with sign omitted.\n        digits = sign + digits;\n    }\n    const negative = sign === NEGATIVE_MARKER;\n    const number = parseFloat(digits);\n    if (!isFinite(number) || isNaN(number)) {\n        return 0;\n    }\n    return Math.round(negative ? (number - MAX_SAFE_INTEGER) : number);\n};\n"
  },
  {
    "__docId__": 5,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "MAX_SAFE_INTEGER",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~MAX_SAFE_INTEGER",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": null,
    "description": " Extracting Number functions to a common module\n\n Numbers are tricky because we want to ensure that they are lexically sortable.",
    "lineNumber": 9,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "NEGATIVE_MARKER",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~NEGATIVE_MARKER",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "POSITIVE_MARKER",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~POSITIVE_MARKER",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "PAD_LENGTH",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~PAD_LENGTH",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 9,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "integerMagnitude",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~integerMagnitude",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "lexicalPad",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~lexicalPad",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "encodeUInt",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~encodeUInt",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": "{encodeUInt}",
    "description": "",
    "lineNumber": 44,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 12,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "encodeInt",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~encodeInt",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": "{encodeInt}",
    "description": "",
    "lineNumber": 49,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "decodeUInt",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~decodeUInt",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": "{decodeUInt}",
    "description": "decode a string expecting a plain unsigned int.",
    "lineNumber": 59,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "decodeInt",
    "memberof": "src/codec/_number_utils.js",
    "longname": "src/codec/_number_utils.js~decodeInt",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/_number_utils",
    "importStyle": "{decodeInt}",
    "description": "Decode a signed number string",
    "lineNumber": 69,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 15,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/bool.js",
    "memberof": null,
    "longname": "src/codec/bool.js",
    "access": null,
    "description": null,
    "lineNumber": 13,
    "content": "/**\n *  Creates a boolean coder/decoder function pair\n *\n *  Boolean Codecs can encode `true` or `false` in a variety of ways.\n *\n *  > Note that by omitting the `stringForFalse`, then `null` is used,\n *  > which \"unset's\" the property on a `false` value.\n *\n *  @param {string} [stringForTrue=\"true\"] - the string to use to signify `true`\n *  @param {?string} [stringForFalse=null] - the string to use to signify `false` (or not expplicitly `true`)\n *  @return {Codec} The custom boolean codec\n */\nexport function createBool(stringForTrue = \"true\", stringForFalse = null) {\n    return {\n        decode: s => s === stringForTrue,\n        encode: s => s ? stringForTrue : stringForFalse\n    };\n}\n\n/**\n *  The default boolean export is one that maps to the strings\n *  \"true\" and \"false\".\n */\nexport default createBool(\"true\", \"false\");\n"
  },
  {
    "__docId__": 16,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createBool",
    "memberof": "src/codec/bool.js",
    "longname": "src/codec/bool.js~createBool",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/bool",
    "importStyle": "{createBool}",
    "description": " Creates a boolean coder/decoder function pair\n\n Boolean Codecs can encode `true` or `false` in a variety of ways.\n\n > Note that by omitting the `stringForFalse`, then `null` is used,\n > which \"unset's\" the property on a `false` value.",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"true\"",
        "defaultRaw": "true",
        "name": "stringForTrue",
        "description": "the string to use to signify `true`"
      },
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "null",
        "defaultRaw": null,
        "name": "stringForFalse",
        "description": "the string to use to signify `false` (or not expplicitly `true`)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Codec"
      ],
      "spread": false,
      "description": "The custom boolean codec"
    },
    "generator": false
  },
  {
    "__docId__": 17,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/enum.js",
    "memberof": null,
    "longname": "src/codec/enum.js",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "content": "/**\n *  Creates a coder/decoder with a fixed set of possible values.\n *\n *  @param {Array<string>} options - The list of values this enum can take.\n *  @return {Codec} the custom enum codec\n */\nexport function createEnum(...options) {\n    const _enum = options.reduce((acc, val) => (acc[val] = val, acc), {});\n    const check = s => (s in _enum) ? s : null;\n    return {\n        decode: check,\n        encode: check\n    };\n}\n"
  },
  {
    "__docId__": 18,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createEnum",
    "memberof": "src/codec/enum.js",
    "longname": "src/codec/enum.js~createEnum",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/enum",
    "importStyle": "{createEnum}",
    "description": " Creates a coder/decoder with a fixed set of possible values.",
    "lineNumber": 7,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "The list of values this enum can take."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Codec"
      ],
      "spread": false,
      "description": "the custom enum codec"
    },
    "generator": false
  },
  {
    "__docId__": 19,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/float.js",
    "memberof": null,
    "longname": "src/codec/float.js",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "content": "/**\n *  The float type is tricky so I haven't implemented it yet.\n *  We need a good algorithm for lexically sortable float encoding.\n */\nthrow new Error(\"float coercion not implemented. Do not import\");\n"
  },
  {
    "__docId__": 20,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/identity.js",
    "memberof": null,
    "longname": "src/codec/identity.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  Identity does no coercion.\n */\nconst identity = x => x;\nexport default {\n    decode: identity,\n    encode: identity\n};\n"
  },
  {
    "__docId__": 21,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "identity",
    "memberof": "src/codec/identity.js",
    "longname": "src/codec/identity.js~identity",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/identity",
    "importStyle": null,
    "description": " Identity does no coercion.",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 22,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/index.js",
    "memberof": null,
    "longname": "src/codec/index.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  Codec define how we manipulate the (mostly) string data in GraphIT\n */\nimport string from \"./string\";\nimport list from \"./list\";\nimport uint from \"./uint\";\nimport int from \"./int\";\nimport json from \"./json\";\nimport { createEnum } from \"./enum\";\nimport bool, { createBool } from \"./bool\";\nimport timestamp from \"./timestamp\";\nimport identity from \"./identity\";\nimport iso8601 from \"./iso8601\";\n\n//NB enum is NOT on this list.\nconst types = {\n    string,\n    list,\n    uint,\n    int,\n    json,\n    bool,\n    timestamp,\n    iso8601,\n    identity\n};\n\n/**\n * Creates a encoder/decoder function pair for the type given.\n *\n * These are used by the {@link Schema} to map values to and from the\n * string-only types used in GraphIT. Theses are used in the property\n * definitions for entities (see {@link createEntity}).\n *\n * @see manual/usage.md#codecs\n * @param {string} name - The name of the codec to create\n *\n * @return {Codec} - the `encode`/`decode` functions\n */\nexport default function createCodec(name) {\n    if (name in types) {\n        return types[name];\n    }\n    //special cases.\n    if (name.indexOf(\"bool:\") === 0) {\n        //split on \":\" and slice off the \"bool\"\n        return createBool(...name.split(\":\").slice(1));\n    }\n\n    if (name.indexOf(\"enum:\") === 0) {\n        return createEnum(...name.split(\":\").slice(1));\n    }\n    //unknown\n    console.warn(`unknown coercion type: ${name}`);\n    return string;\n}\n"
  },
  {
    "__docId__": 23,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "types",
    "memberof": "src/codec/index.js",
    "longname": "src/codec/index.js~types",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 24,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCodec",
    "memberof": "src/codec/index.js",
    "longname": "src/codec/index.js~createCodec",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec",
    "importStyle": "createCodec",
    "description": "Creates a encoder/decoder function pair for the type given.\n\nThese are used by the {@link Schema} to map values to and from the\nstring-only types used in GraphIT. Theses are used in the property\ndefinitions for entities (see {@link createEntity}).",
    "see": [
      "manual/usage.md#codecs"
    ],
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the codec to create"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Codec"
      ],
      "spread": false,
      "description": "the `encode`/`decode` functions"
    },
    "generator": false
  },
  {
    "__docId__": 25,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/int.js",
    "memberof": null,
    "longname": "src/codec/int.js",
    "access": null,
    "description": null,
    "lineNumber": 18,
    "content": "/**\n *  Integer marshalling is more complex than you would think.\n *  In order to enable sorting on these fields, we have to zero-pad them.\n *  This is because the string values are lexical sorted, so \"10\" comes before \"2\" but not \"02\".\n *\n *  We zero-pad to MAX_SAFE_INTEGER to account for javascripts float-only number system.\n *\n *  Instead of checking for an integer, we simply Math.floor the values.\n *\n *  To account for sign, we subtract negative numbers from MAX_SAFE_INTEGER and prefix with a marker,\n *  positive numbers are prefixed with a different marker.\n *\n *  This has the unfortunate effect of making the database values non-human-readable, but allows sane sorting.\n *\n *  If you do not need negative numbers it is more natural (and probably more performant) to\n *  use the `uint` type.\n */\nimport {\n    encodeInt as encode,\n    decodeInt as decode\n} from \"./_number_utils\";\n\nexport default { encode, decode };\n"
  },
  {
    "__docId__": 26,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/iso8601.js",
    "memberof": null,
    "longname": "src/codec/iso8601.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  The best way to store timestamps.\n */\nconst encode = s => {\n    if (typeof s === \"object\" && \"getUTCDate\" in s) {\n        return dateToISO8601(s);\n    }\n    let n;\n    if (typeof s === \"string\") {\n        n = parseInt(s, 10);\n    } else {\n        n = 1 * s; //cast to number...\n    }\n    return dateToISO8601(new Date(n));\n};\n\n//be liberal in what you accept...\nconst decode = s => {\n    let ts = Date.parse(s);\n    if (isNaN(ts)) {\n        //maybe this was an timestamp.\n        ts = parseInt(s, 10);\n    }\n    return isNaN(ts) ? null : ts;\n};\n\nexport default { encode, decode };\n\n/**\n * this is a check to see if this could be an ISO8601 - it does not cover all possibilities\n * @ignore\n */\nexport const isoRegex = /^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}/;\n\nconst dateToISO8601 = date => {\n    const time = date.getTime();\n    if (isNaN(time)) {\n        return null; //invalid dates are still dates :(\n    }\n    if (typeof date.getISOString === \"function\") {\n        return date.getISOString();\n    }\n    //otherwise, we have to do it ourselves\n    //the format is simple:\n    // yyyy-mm-ddThh:mm:ss.sssZ\n    const [year, month, day, hour, min, second, ms] = [\n        date.getUTCFullYear(),\n        date.getUTCMonth() + 1,\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n    return `${year}-${pad(month)}-${pad(day)}T${pad(hour)}:${pad(min)}:${pad(second)}.${pad3(ms)}Z`;\n};\n\nconst pad = n => n > 9 ? n : \"0\" + n;\nconst pad3 = n => n > 99 ? n : \"0\" + pad(n);\n\n"
  },
  {
    "__docId__": 27,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "encode",
    "memberof": "src/codec/iso8601.js",
    "longname": "src/codec/iso8601.js~encode",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/iso8601",
    "importStyle": null,
    "description": " The best way to store timestamps.",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 28,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "decode",
    "memberof": "src/codec/iso8601.js",
    "longname": "src/codec/iso8601.js~decode",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/iso8601",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 29,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "isoRegex",
    "memberof": "src/codec/iso8601.js",
    "longname": "src/codec/iso8601.js~isoRegex",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/codec/iso8601",
    "importStyle": "{isoRegex}",
    "description": "this is a check to see if this could be an ISO8601 - it does not cover all possibilities",
    "lineNumber": 33,
    "ignore": true,
    "type": {
      "types": [
        "object"
      ]
    }
  },
  {
    "__docId__": 30,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "dateToISO8601",
    "memberof": "src/codec/iso8601.js",
    "longname": "src/codec/iso8601.js~dateToISO8601",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/iso8601",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 31,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "pad",
    "memberof": "src/codec/iso8601.js",
    "longname": "src/codec/iso8601.js~pad",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/iso8601",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 32,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "pad3",
    "memberof": "src/codec/iso8601.js",
    "longname": "src/codec/iso8601.js~pad3",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/iso8601",
    "importStyle": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 33,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/json.js",
    "memberof": null,
    "longname": "src/codec/json.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  Copes with values that have complex values stored as strings\n */\nexport default {\n    decode: s => {\n        try {\n            return JSON.parse(s);\n        } catch (e) {\n            //no valid json return as is.\n            return s;\n        }\n    },\n    encode: s => {\n        try {\n            return JSON.stringify(s);\n        } catch (e) {\n            //should we throw here, or swallow silently...\n            return null;\n        }\n    }\n};\n"
  },
  {
    "__docId__": 34,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/list.js",
    "memberof": null,
    "longname": "src/codec/list.js",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "content": "/**\n *  The list type is a comma-seperated list of entries in the db,\n *  but an array locally. We also accept a raw string locally\n */\n\nconst toStringAndTrim = input => {\n    if (input === undefined || input === null) {\n        return \"\";\n    }\n    const string = \"\" + input;\n    return string.replace(/(^\\s*|\\s*$)/g, \"\");\n};\n\nconst decode = string => {\n    let s = string;\n    if (typeof string !== \"string\") {\n        s = \"\" + string;\n    }\n    return s\n        .split(/\\s*,\\s*/)\n        .map(toStringAndTrim) //cast values to string and trim them\n        .filter(Boolean); //remove empty strings.\n};\n\nconst encode = array => {\n    let arr;\n    if (!Array.isArray(array)) {\n        arr = decode(array);\n    } else {\n        arr = array.map(toStringAndTrim).filter(Boolean);\n    }\n    return arr.join(\", \");\n};\n\nexport default { decode, encode };\n"
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "toStringAndTrim",
    "memberof": "src/codec/list.js",
    "longname": "src/codec/list.js~toStringAndTrim",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/list",
    "importStyle": null,
    "description": " The list type is a comma-seperated list of entries in the db,\n but an array locally. We also accept a raw string locally",
    "lineNumber": 6,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "decode",
    "memberof": "src/codec/list.js",
    "longname": "src/codec/list.js~decode",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/list",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 37,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "encode",
    "memberof": "src/codec/list.js",
    "longname": "src/codec/list.js~encode",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/list",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/string.js",
    "memberof": null,
    "longname": "src/codec/string.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  String ensure whatever is given is string.\n */\nconst stringify = s => {\n    if (s === null || s === undefined) {\n        return \"\";\n    }\n    if (typeof s === \"string\") {\n        return s;\n    }\n    return \"\" + s;\n};\n\nexport default {\n    decode: stringify,\n    encode: stringify\n};\n"
  },
  {
    "__docId__": 39,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stringify",
    "memberof": "src/codec/string.js",
    "longname": "src/codec/string.js~stringify",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/string",
    "importStyle": null,
    "description": " String ensure whatever is given is string.",
    "lineNumber": 4,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 40,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/timestamp.js",
    "memberof": null,
    "longname": "src/codec/timestamp.js",
    "access": null,
    "description": null,
    "lineNumber": 12,
    "content": "/**\n *  Timestamp is a millisecond precision unix timestamp.\n *\n *  because it is stored as a string, it is only valid for ordering\n *  while millisecond timestamps have 13 digits. That means you can only\n *  use timestamps that fall in the range:\n *  from ~ \"Sun, 09 Sep 2001 01:46:39 GMT\"\n *  to ~ \"Sat, 20 Nov 2286 17:46:40 GMT\"\n *\n *  It's altogether a better idea to use ISO8601 timestamps\n */\nimport iso, { isoRegex } from \"./iso8601\";\n\nconst TS_LOWER_BOUND = 999999999999;\nconst TS_UPPER_BOUND = 10000000000000;\n\nexport default {\n    decode: s => {\n        let n = parseInt(s, 10);\n        if (isoRegex.test(s)) {\n            n = iso.decode(s);\n        }\n        return (isNaN(n) || n < TS_LOWER_BOUND || n > TS_UPPER_BOUND) ? null : n;\n    },\n    encode: s => {\n        let n;\n        if (typeof s === \"string\") {\n            n = parseInt(s, 10);\n        } else {\n            n = 1 * s; //cast to number...\n        }\n        //now finally if a reasonable number, cast back to string...\n        return (isNaN(n) || n < TS_LOWER_BOUND || n > TS_UPPER_BOUND) ? null : \"\" + n;\n    }\n};\n"
  },
  {
    "__docId__": 41,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "TS_LOWER_BOUND",
    "memberof": "src/codec/timestamp.js",
    "longname": "src/codec/timestamp.js~TS_LOWER_BOUND",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/timestamp",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "TS_UPPER_BOUND",
    "memberof": "src/codec/timestamp.js",
    "longname": "src/codec/timestamp.js~TS_UPPER_BOUND",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/codec/timestamp",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 43,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/codec/uint.js",
    "memberof": null,
    "longname": "src/codec/uint.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n *  Stores positive integer data. (discards sign)\n *\n *  because it is a string, we use the *easiest* (not the most compact or versatile) format\n *  that is still sortable.\n *\n */\nimport {\n    encodeUInt as encode,\n    decodeUInt as decode\n} from \"./_number_utils\";\n\nexport default { encode, decode };\n"
  },
  {
    "__docId__": 44,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/context/context_entity.doc.js",
    "memberof": null,
    "longname": "src/context/context_entity.doc.js",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "content": "/**\n * A {@link Context} has properties named after each Entity with a set of bound functions\n *\n *  This fake class documents the methods attached to each entity name.\n */\nexport class Context$Entity {\n    /**\n     *  find vertices of type `Entity`\n     *\n     *  @param {LuceneQuery} query - the lucene query to use for search\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<Array<GraphVertex>>}\n     */\n    find(query, options) { } //eslint-disable-line\n\n    /**\n     *  find vertices of type `<Entity>` by Id or an array of ids\n     *\n     *  @param {string|Array<string>} idOrIds - the lucene query to use for search\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<OneOrMoreVertices>}\n     */\n    findById(idOrIds, options) { } //eslint-disable-line\n\n    /**\n     *  find the first vertex of type `<Entity>`\n     *\n     *  @param {LuceneQuery} query - the lucene query to use for search\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<GraphVertex>}\n     */\n    findOne(query, options) { } //eslint-disable-line\n\n    /**\n     *  find vertices of type `Entity` that match the search term as well as the filter\n     *\n     *  @param {string|object} term - the search term or `$search` object (see [Lucene Queries](../../../manual/usage.html#-search-queries))\n     *  @param {LuceneQuery} filter - the lucene query to used to limit results\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<Array<GraphVertex>>}\n     */\n    search(term, filter, options) { } //eslint-disable-line\n\n    /**\n     *  create a new vertex of type `<Entity>`\n     *\n     *  @param {object} appData - the data for the new vertex\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<GraphVertex>}\n     */\n    create(appData, options) { } //eslint-disable-line\n\n    /**\n     *  Connect 2 vertices with a given relation\n     *\n     *  The edge will be `{source}$${verb}$${target}`.\n     *  The verb is inferred from the `relation` parameter.\n     *\n     *  @param {string} relation - the named relation to connect by\n     *  @param {string} source - the ID of the source vertex\n     *  @param {string} target - the ID of the target vertex\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<undefined>} - just a promise that resolves when connected\n     */\n    connect(relation, source, target, options) { } //eslint-disable-line\n\n    /**\n     *  Disconnect 2 vertices along a given relation.\n     *\n     *  The edge deleted will be `{source}$${verb}$${target}`.\n     *  The verb is inferred from the `relation` parameter.\n     *\n     *  @param {string} relation - the named relation to disconnect\n     *  @param {string} source - the ID of the source vertex\n     *  @param {string} target - the ID of the target vertex\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<undefined>} - just a promise that resolves when connected\n     */\n    disconnect(relation, source, target, options) { } //eslint-disable-line\n\n     /**\n     *  update a new vertex with new data.\n     *\n     *  @param {string} id - the ID of the vertex to update\n     *  @param {object} appData - the data for the new vertex\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<GraphVertex>}\n     */\n    update(id, appData, options) { } //eslint-disable-line\n\n    /**\n     *  replace a new vertex with new data (destructive!)\n     *\n     *  @param {string} id - the ID of the vertex to update\n     *  @param {object} appData - the data for the new vertex\n     *  @param {object} [options={}] - extra options for the query\n     *  @return {Promise<GraphVertex>}\n     */\n    replace(id, appData, options) { } //eslint-disable-line\n\n    /**\n     *  Encode application data to graph data.\n     *\n     *  @param {object} appData - application level data\n     *  @return {object} graphData - graph encoded data\n     */\n    encode(appData) { } //eslint-disable-line\n\n    /**\n     *  Decode graph data to application data.\n     *\n     *  @param {object} graphData - graph encoded data\n     *  @return {object} appData - application level data\n     */\n    decode(graphData) { } //eslint-disable-line\n\n    /**\n     *  Generate the Gremlin Query factoty for the given relation.\n     *\n     *  @example\n     *      query = ctx.Entity.relationQuery(\"relates\");\n     *      gremlin = query(ctx.gremlin());\n     *      gremlin.execute(rootId).then(...)\n     *\n     *  @param {string} relation - the name of the relation\n     *  @return {GremlinBranch}\n     */\n    relationQuery(relation) { } //eslint-disable-line\n\n    /**\n     *  used internally\n     *  @ignore\n     */\n    fetchVertices(relations, options) { } //eslint-disable-line\n    /**\n     *  used internally\n     *  @ignore\n     */\n    fetchIds(relations, options) { } //eslint-disable-line\n    /**\n     *  used internally\n     *  @ignore\n     */\n    fetchCount(relations, options) { } //eslint-disable-line\n}\n"
  },
  {
    "__docId__": 45,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Context$Entity",
    "memberof": "src/context/context_entity.doc.js",
    "longname": "src/context/context_entity.doc.js~Context$Entity",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/context_entity.doc",
    "importStyle": "{Context$Entity}",
    "description": "A {@link Context} has properties named after each Entity with a set of bound functions\n\n This fake class documents the methods attached to each entity name.",
    "lineNumber": 6,
    "interface": false
  },
  {
    "__docId__": 46,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "find",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#find",
    "access": null,
    "description": " find vertices of type `Entity`",
    "lineNumber": 14,
    "params": [
      {
        "nullable": null,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the lucene query to use for search"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<GraphVertex>>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 47,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "findById",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#findById",
    "access": null,
    "description": " find vertices of type `<Entity>` by Id or an array of ids",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "idOrIds",
        "description": "the lucene query to use for search"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 48,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "findOne",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#findOne",
    "access": null,
    "description": " find the first vertex of type `<Entity>`",
    "lineNumber": 32,
    "params": [
      {
        "nullable": null,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the lucene query to use for search"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 49,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "search",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#search",
    "access": null,
    "description": " find vertices of type `Entity` that match the search term as well as the filter",
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "term",
        "description": "the search term or `$search` object (see [Lucene Queries](../../../manual/usage.html#-search-queries))"
      },
      {
        "nullable": null,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "filter",
        "description": "the lucene query to used to limit results"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<Array<GraphVertex>>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 50,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "create",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#create",
    "access": null,
    "description": " create a new vertex of type `<Entity>`",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "appData",
        "description": "the data for the new vertex"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 51,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "connect",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#connect",
    "access": null,
    "description": " Connect 2 vertices with a given relation\n\n The edge will be `{source}$${verb}$${target}`.\n The verb is inferred from the `relation` parameter.",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the named relation to connect by"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "the ID of the source vertex"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "the ID of the target vertex"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined>"
      ],
      "spread": false,
      "description": "just a promise that resolves when connected"
    },
    "generator": false
  },
  {
    "__docId__": 52,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "disconnect",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#disconnect",
    "access": null,
    "description": " Disconnect 2 vertices along a given relation.\n\n The edge deleted will be `{source}$${verb}$${target}`.\n The verb is inferred from the `relation` parameter.",
    "lineNumber": 79,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the named relation to disconnect"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "source",
        "description": "the ID of the source vertex"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "target",
        "description": "the ID of the target vertex"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined>"
      ],
      "spread": false,
      "description": "just a promise that resolves when connected"
    },
    "generator": false
  },
  {
    "__docId__": 53,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "update",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#update",
    "access": null,
    "description": " update a new vertex with new data.",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the ID of the vertex to update"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "appData",
        "description": "the data for the new vertex"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 54,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "replace",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#replace",
    "access": null,
    "description": " replace a new vertex with new data (destructive!)",
    "lineNumber": 99,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "id",
        "description": "the ID of the vertex to update"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "appData",
        "description": "the data for the new vertex"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "extra options for the query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 55,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "encode",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#encode",
    "access": null,
    "description": " Encode application data to graph data.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "appData",
        "description": "application level data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "graphData - graph encoded data"
    },
    "generator": false
  },
  {
    "__docId__": 56,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "decode",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#decode",
    "access": null,
    "description": " Decode graph data to application data.",
    "lineNumber": 115,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "graphData",
        "description": "graph encoded data"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "appData - application level data"
    },
    "generator": false
  },
  {
    "__docId__": 57,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "relationQuery",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#relationQuery",
    "access": null,
    "description": " Generate the Gremlin Query factoty for the given relation.",
    "examples": [
      "     query = ctx.Entity.relationQuery(\"relates\");\n     gremlin = query(ctx.gremlin());\n     gremlin.execute(rootId).then(...)"
    ],
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the name of the relation"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinBranch"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 58,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchVertices",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#fetchVertices",
    "access": null,
    "description": " used internally",
    "lineNumber": 134,
    "ignore": true,
    "params": [
      {
        "name": "relations",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 59,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchIds",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#fetchIds",
    "access": null,
    "description": " used internally",
    "lineNumber": 139,
    "ignore": true,
    "params": [
      {
        "name": "relations",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 60,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchCount",
    "memberof": "src/context/context_entity.doc.js~Context$Entity",
    "longname": "src/context/context_entity.doc.js~Context$Entity#fetchCount",
    "access": null,
    "description": " used internally",
    "lineNumber": 144,
    "ignore": true,
    "params": [
      {
        "name": "relations",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 61,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/context/graph.js",
    "memberof": null,
    "longname": "src/context/graph.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n *  The Graph interaction methods.\n *\n *  These wrap the base methods, the gremlin relation queries,\n *  the context and entity definitions to produce Vertex objects\n *  from queries.\n */\nimport { notFound, badRequest } from \"hiro-graph-client/lib/errors\";\nimport { decodeResults, filter, mapIfArray } from \"../utils\";\nimport parseLucene from \"../lucene\";\nimport { createVertex, isVertex } from \"../vertex/graph\";\n\n//this is not in utils, so utils doesn't need to import GraphVertex\nconst createVertices = ctx => mapIfArray(data => createVertex(data, ctx));\n\n//this is a pipeline of a few functions.\n//first decode results, then filter empties, then turn to vertexes.\n//the ctx._schema.get() with no arg is the internal entity, used\n//when we don't know the type in advance\n/**\n * @ignore\n */\nexport const vertexize = (ctx, entity = ctx._schema.get()) => input => {\n    return Promise.resolve(input)\n        .then(decodeResults(ctx, entity))\n        .then(filter(Boolean))\n        .then(createVertices(ctx));\n};\n\n//this is for results that expect a single result.\nconst returnOneOrThrow = result => {\n    if (!result || result.length === 0) {\n        throw notFound(\"single vertex not found\");\n    }\n    return Array.isArray(result) ? result[0] : result;\n};\n\n/**\n * @ignore\n */\nexport function find(ctx, entity, query, options = {}) {\n    const { querystring, placeholders } = parseLucene(query, entity);\n    const luceneOptions = Object.assign({}, options, placeholders);\n    return ctx._connection.lucene(querystring, luceneOptions)\n        .then(vertexize(ctx, entity));\n}\n\n/**\n * @ignore\n */\nexport function findOne(ctx, entity, query, options = {}) {\n    return find(ctx, entity, query, options)\n        .then(returnOneOrThrow);\n}\n\n//this function return the response from the callback\n// in which ever case.\nconst noop = () => {};\nconst cacheCheck = (entity, cache, id, { isCached = noop, isCachedButWrongType = noop, notCached = noop }) => {\n    const cached = cache.get(id);\n    console.log(\"check cache\", id, cached);\n    //the second check is in case errors or something else get in the cache\n    if (!cached || !isVertex(cached)) {\n        return notCached(id);\n    }\n    if (entity && !entity.internal && entity.name !== cached.type()) {\n        return isCachedButWrongType(cached);\n    }\n    return isCached(cached);\n};\n\n//get Me is a little different as we have no ID to start with,\n//but we will get an \"ogit/Person\" node.\n/**\n * @ignore\n */\nexport function fetchMe(ctx) {\n    const entity = ctx.getEntity(\"ogit/Person\");\n    return ctx._connection.me()\n        .then(vertexize(ctx, entity))\n        .then(returnOneOrThrow);\n}\n\n//find by ID can do multiple things.\n//first it can be given either one or many ids.\n//also if entity is null, we should use the IDs query.\n/**\n * @ignore\n */\nexport function findById(ctx, entity, query, options = {}) {\n    if (Array.isArray(query)) {\n        //do an ids query.\n        const cached = [];\n        let toFetch;\n        if (!options.refetch) {\n            const callbacks = {\n                isCached: vertex => {\n                    cached.push(vertex);\n                    return false; //\n                },\n                isCachedButWrongType: () => false,\n                notCached: id => id\n            };\n            toFetch = query\n                .map(id => cacheCheck(entity, ctx._cache, id, callbacks))\n                .filter(Boolean);\n        } else {\n            toFetch = query;\n        }\n        const fetched = (toFetch.length === 0)\n            ? Promise.resolve([])\n            : ctx._connection.ids(toFetch, options).then(vertexize(ctx, entity));\n\n        return fetched\n            .then(vertices => cached.concat(vertices));\n    }\n    //check cache first.\n    if (!options.refetch) {\n        const cached = cacheCheck(entity, ctx._cache, query, {\n            isCached: vertex => vertex,\n            isCachedButWrongType: () => false,\n            notCached: () => false\n        });\n        if (cached) {\n            return Promise.resolve(cached);\n        }\n    }\n    return findOne(ctx, entity, { _id: query }, options);\n}\n\n/**\n * @ignore\n */\nexport function search(ctx, entity, query, filters = {}, options = {}) {\n    return find(ctx, entity, Object.assign({ $search: query }, filters), options);\n}\n\n/**\n * @ignore\n */\nexport function create(ctx, entity, data, options = {}) {\n    if (options.addCreatedOn && !data.created_on) {\n        data.created_on = Date.now();\n    }\n    const dbData = entity.encode(data);\n    return ctx._connection.create(entity.ogit, dbData, options)\n        .then(vertexize(ctx, entity));\n}\n\n/**\n * @ignore\n */\nexport function update(ctx, entity, vertexId, data, options = {}) {\n    const dbData = entity.encode(data);\n    return ctx._connection.update(vertexId, dbData, options)\n        .then(vertexize(ctx, entity));\n}\n\n/**\n * @ignore\n */\nexport function replace(ctx, entity, vertexId, data, options = {}) {\n    const dbData = entity.encode(data);\n    return ctx._connection.replace(vertexId, dbData, options)\n        .then(vertexize(ctx, entity));\n}\n\n/**\n * @ignore\n */\nexport function deleteVertex(ctx, vertexId, options = {}) {\n    return ctx._connection.delete(vertexId, options);\n}\n\n/**\n * @ignore\n */\nexport function connect(ctx, entity, { relation, source, target }, options = {}) {\n    const relationDef = entity.relation(relation);\n    if (!relationDef) {\n        throw badRequest(`No Relation ${relation} defined for ${entity.name}`);\n    }\n    if (relationDef.hops.length > 1) {\n        throw badRequest(`Cannot \"connect\" multi-hop relation ${relation} for ${entity.name}`);\n    }\n    const { verb, direction } = relationDef.hops[0];\n    const [inId, outId] = direction === \"in\" ? [source, target] : [target, source];\n    return ctx._connection.connect(verb, inId, outId, options);\n}\n\n/**\n * @ignore\n */\nexport function disconnect(ctx, entity, { relation, source, target }, options = {}) {\n    const relationDef = entity.relation(relation);\n    if (!relationDef) {\n        throw badRequest(`No Relation ${relation} defined for ${entity.name}`);\n    }\n    if (relationDef.hops.length > 1) {\n        throw badRequest(`Cannot \"disconnect\" multi-hop relation ${relation} for ${entity.name}`);\n    }\n    const { verb, direction } = relationDef.hops[0];\n    const [inId, outId] = direction === \"in\" ? [source, target] : [target, source];\n    return ctx._connection.disconnect(verb, inId, outId, options);\n}\n\n/**\n * @ignore\n */\nexport function gremlin(ctx, rootVertexId, query, options = {}) {\n    const queryResults = ctx._connection.gremlin(rootVertexId, query.toString(), options);\n    if (options.raw) {\n        return queryResults;\n    }\n    return queryResults.then(vertexize(ctx));\n}\n"
  },
  {
    "__docId__": 62,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createVertices",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~createVertices",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "vertexize",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~vertexize",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{vertexize}",
    "description": "",
    "lineNumber": 23,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "returnOneOrThrow",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~returnOneOrThrow",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "find",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~find",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{find}",
    "description": "",
    "lineNumber": 41,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 66,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "findOne",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~findOne",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{findOne}",
    "description": "",
    "lineNumber": 51,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 67,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "noop",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~noop",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "cacheCheck",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~cacheCheck",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "fetchMe",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~fetchMe",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{fetchMe}",
    "description": "",
    "lineNumber": 77,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 70,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "findById",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~findById",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{findById}",
    "description": "",
    "lineNumber": 90,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 71,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "search",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~search",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{search}",
    "description": "",
    "lineNumber": 134,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "filters",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 72,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "create",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~create",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{create}",
    "description": "",
    "lineNumber": 141,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 73,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "update",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~update",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{update}",
    "description": "",
    "lineNumber": 153,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "vertexId",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 74,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "replace",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~replace",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{replace}",
    "description": "",
    "lineNumber": 162,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "vertexId",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 75,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "deleteVertex",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~deleteVertex",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{deleteVertex}",
    "description": "",
    "lineNumber": 171,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "vertexId",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 76,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "connect",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~connect",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{connect}",
    "description": "",
    "lineNumber": 178,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"relation\": *, \"source\": *, \"target\": *}"
        ],
        "defaultRaw": {
          "relation": null,
          "source": null,
          "target": null
        },
        "defaultValue": "{\"relation\":null,\"source\":null,\"target\":null}"
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 77,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "disconnect",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~disconnect",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{disconnect}",
    "description": "",
    "lineNumber": 194,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern2",
        "types": [
          "{\"relation\": *, \"source\": *, \"target\": *}"
        ],
        "defaultRaw": {
          "relation": null,
          "source": null,
          "target": null
        },
        "defaultValue": "{\"relation\":null,\"source\":null,\"target\":null}"
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 78,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "gremlin",
    "memberof": "src/context/graph.js",
    "longname": "src/context/graph.js~gremlin",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/graph",
    "importStyle": "{gremlin}",
    "description": "",
    "lineNumber": 210,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "rootVertexId",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 79,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/context/index.js",
    "memberof": null,
    "longname": "src/context/index.js",
    "access": null,
    "description": null,
    "lineNumber": 7,
    "content": "/**\n *  Defines a Schema aware GraphIT connection library\n *\n *\n *\n */\nimport { queryBuilder } from \"../gremlin\";\nimport {\n    find,\n    findById,\n    findOne,\n    search,\n    create,\n    update,\n    replace,\n    connect,\n    disconnect,\n    deleteVertex,\n    fetchMe\n} from \"./graph\";\nimport { createVertex } from \"../vertex/graph\";\nimport { mapPromiseIfArray } from \"../utils\";\nimport { getRelationQuery, fetchVertices, fetchIds, fetchCount } from \"./relations\";\nimport isPlainObject from \"lodash.isplainobject\";\nimport Schema from \"../schema\";\nimport { Connection } from \"hiro-graph-client\";\n\n//shorthand for creating the getCount/Ids/Vertices fetching functions\nconst relationFetch = (method, relations, options = {}) => mapPromiseIfArray(vertex => vertex[method](relations, options));\n\n/**\n *  The context is a wrapper for the schema and connection.\n *\n *  The major expost of the entire module.\n *\n *  Apart from it's direct methods, every {@link Entity} in the {@link Schema} has a\n *  property on this object, which has the methods documented in {@link Context$Entity}.\n */\nexport default class Context {\n    /**\n     *  @param {Connection|object} connectionSpec - This should be an `hiro-graph-client` `Connection` object,\n     *                                              or the constructor args to create one.\n     *  @param {Schema|Array} schemaSpec - This should be a {@link Schema} or the constructor args to create one.\n     *  @param {?Map} [cache=new&nbsp;Map()] - The vertex cache. Any object satisfying the `Map` interface should be OK.\n     */\n    constructor(connectionSpec, schemaSpec, cache = new Map()) {\n        let connection = connectionSpec;\n        if (isPlainObject(connectionSpec)) {\n            connection = new Connection(connectionSpec);\n        }\n\n        let schema = schemaSpec;\n        if (Array.isArray(schemaSpec)) {\n            schema = new Schema(schemaSpec);\n        }\n\n        this._connection = connection;\n        this._schema = schema;\n        this._cache = cache;\n        this._log = [];\n\n        //this adds the instance specific methods for each entity type\n        //and one for \"_no_entity\"\n        mapEntityShortcuts(this, [\"_no_entity\"].concat(schema.names));\n    }\n\n    /**\n     *  This returns the vertex from the owner of the access token in use.\n     *  @return {Promise<GraphVertex>}\n     */\n    me() {\n        //this is a bit different.\n        return fetchMe(this);\n    }\n\n    /**\n     * Get's the underlying GraphIT connection.\n     *\n     * @return {Connection}\n     */\n    getConnection() {\n        return this._connection;\n    }\n\n    /**\n     * Exchange the current cache for a new one.\n     *\n     * You likely want to do this early on, before\n     * any entries have gone in.\n     *\n     * @param {Map} cache - the new cache to use. Only needs to satisfy the `Map` interface, not actually be a `Map`\n     */\n    setCache(cache) {\n        this._cache = cache;\n    }\n\n    /**\n     *  On the Context itself, this is an `un-typed` query for a single vertex.\n     *\n     *  i.e. will search all entity types and return any one of them.\n     *\n     *  @param {LuceneQuery} query - the lucene query to perform\n     *  @param {object} options - the options to pass on to the query {@todo document these}\n     *  @return {Promise<GraphVertex>} - the first vertex found or an error\n     */\n    findOne(query, options = {}) {\n        return this._no_entity.findOne(query, options);\n    }\n    /**\n     *  On the Context itself, this is an `un-typed` query by id only\n     *\n     *  i.e. will search all entity types for the given id or array of ids.\n     *\n     *  @param {string|Array<string>} idOrIds - the id or array of ids to fetch\n     *  @param {object} options - the options to pass on to the query {@todo document these}\n     *  @return {Promise<OneOrMoreVertices>} - the vertex/vertices found or an error\n     */\n    findById(idOrIds, options = {}) {\n        return this._no_entity.findById(idOrIds, options);\n    }\n\n    /**\n     *  On the Context itself, this is an `un-typed` query.\n     *\n     *  i.e. will search all entity types and return any of them.\n     *\n     *  @param {LuceneQuery} query - the lucene query to perform\n     *  @param {object} options - the options to pass on to the query {@todo document these}\n     *  @return {Promise<OneOrMoreVertices>} - the first vertex found or an error\n     */\n    find(query, options = {}) {\n        return this._no_entity.find(query, options);\n    }\n    /**\n     *  On the Context itself, this is an `un-typed` search.\n     *\n     *  i.e. will search all entity types and return any of them.\n     *\n     *  @param {string|object} query - the search term or search definition.\n     *  @param {LuceneQuery} filter - the lucene query to further restrict the results\n     *  @param {object} options - the options to pass on to the query {@todo document these}\n     *  @return {Promise<OneOrMoreVertices>} - the first vertex found or an error\n     */\n    search(query, filter = {}, options = {}) {\n        return this._no_entity.search(query, options);\n    }\n\n    /**\n     *  Deletes a vertex by id.\n     *\n     *  @param {string} vertexId - the id of the vertex to delete\n     *  @param {object} options - the options to pass on to the query {@todo document these}\n     *  @return {Promise<GraphVertex>} - the vertex (marked as deleted)\n     */\n    delete(vertexId, options = {}) {\n        return deleteVertex(this, vertexId, options);\n    }\n\n    /**\n     *  Create A Gremlin Query Builder with Context.\n     *\n     *  @param {?string} initialQuery - the starting point for the new query.\n     *  @return {GremlinQueryBuilder} - a context aware gremlin query builder (e.g. `query.execute()` will work)\n     */\n    gremlin(initialQuery) {\n        return queryBuilder(initialQuery, this);\n    }\n\n    /**\n     *  Passthrough a count fetch in a promise\n     *\n     *  @example\n     *  context.find({}).then(context.fetchCounts([\"related\"]));\n     *\n     *  @param {Array<string>} relations - the relations to query for. These should match valid relation names on the entities passed in.\n     *  @param {object} options - options to pass through to the underlying call\n     *  @return {function(items: OneOrMoreVertices): Promise<OneOrMoreVertices>}\n     *      - returns a function which will call `fetchCount(relations, options)` on each input\n     */\n    fetchCount(relations, options = {}) {\n        return relationFetch(\"fetchCount\", relations, options);\n    }\n\n    /**\n     *  Passthrough a id fetch in a promise\n     *\n     *  @example\n     *  context.find({}).then(context.fetchIds([\"related\"]));\n     *\n     *  @param {Array<string>} relations - the relations to query for. These should match valid relation names on the entities passed in.\n     *  @param {object} options - options to pass through to the underlying call\n     *  @return {function(items: OneOrMoreVertices): Promise<OneOrMoreVertices>}\n     *      - returns a function which will call `fetchIds(relations, options)` on each input\n     */\n    fetchIds(relations, options = {}) {\n        return relationFetch(\"fetchIds\", relations, options);\n    }\n\n    /**\n     *  Passthrough a vertex fetch in a promise\n     *\n     *  @example\n     *  context.find({}).then(context.fetchVertices([\"related\"]));\n     *\n     *  @param {Array<string>} relations - the relations to query for. These should match valid relation names on the entities passed in.\n     *  @param {object} options - options to pass through to the underlying call\n     *  @return {function(items: OneOrMoreVertices): Promise<OneOrMoreVertices>}\n     *      - returns a function which will call `fetchVertices(relations, options)` on each input\n     */\n    fetchVertices(relations, options = {}) {\n        return relationFetch(\"fetchVertices\", relations, options);\n    }\n\n    /**\n     *  Fetch an entity from the schema.\n     *\n     *  @param {string} name - the name of the entity, can be the application name, or the OGIT name\n     *  @return {?Entity} - the entity if found.\n     */\n    getEntity(name) {\n        return this._schema.get(name);\n    }\n\n    /**\n     *  Manually remove an item from the ORM cache.\n     *\n     *  @param {string} vertexId - the ID of the vertex to drop.\n     *  @return {undefined} - no return value\n     */\n    remove(vertexId) {\n        this.cache.delete(vertexId);\n    }\n\n    /**\n     *  Manually give the orm data, raw from Graphit\n     *\n     *  Useful when you have have to bypass the regular system, or have nodes stored somewhere else.\n     *\n     *  @param {object} rawData - the raw GraphIT vertex data;\n     *  @return {GraphVertex} - the inserted vertex\n     */\n    insertRaw(rawData) {\n        const entity = this.getEntity(rawData[\"ogit/_type\"]);\n        const decoded = entity.decode(rawData);\n        return this.insert(decoded);\n    }\n\n    /**\n     *  Manually give the orm data, in application format\n     *\n     *  @param {object} appData - the application vertex data object\n     *  @return {GraphVertex} - the inserted vertex\n     */\n    insert(appData) {\n        return createVertex(appData, this);\n    }\n}\n\nconst mixinMethods = {\n    find: (ctx, entity) => (query, options = {}) => find(ctx, entity, query, options),\n    findById: (ctx, entity) => (idOrIds, options = {}) => findById(ctx, entity, idOrIds, options),\n    findOne: (ctx, entity) => (query, options = {}) => findOne(ctx, entity, query, options),\n    search: (ctx, entity) => (query, filter, options = {}) => search(ctx, entity, query, options),\n    create: (ctx, entity) => (data, options = {}) => create(ctx, entity, data, options),\n    connect: (ctx, entity) => (relation, source, target, options = {}) => connect(ctx, entity, { relation, source, target }, options),\n    disconnect: (ctx, entity) => (relation, source, target, options = {}) => disconnect(ctx, entity, { relation, source, target }, options),\n    update: (ctx, entity) => (vertexId, appData, options = {}) => update(ctx, entity, vertexId, appData, options),\n    replace: (ctx, entity) => (vertexId, appData, options = {}) => replace(ctx, entity, vertexId, appData, options),\n    encode: (ctx, entity) => appData => entity.encode(appData),\n    decode: (ctx, entity) => graphData => entity.decode(graphData),\n    relationQuery: (ctx, entity) => relation => getRelationQuery(entity, relation),\n    fetchVertices,\n    fetchIds,\n    fetchCount\n};\nconst mixinMethodNames = Object.keys(mixinMethods);\n\n//Adds entity methods\n//\n// like ctx.Profile.find()\nconst mapEntityShortcuts = (ctx, names) => {\n    //we add \"_unbound\" to add use for the unbound instance methods.\n    //they have a null entity, the others get an Identity\n    names.forEach(name => {\n        const entity = ctx._schema.get(name);\n        ctx[name] = mixinMethodNames.reduce((obj, method) => {\n            obj[method] = mixinMethods[method](ctx, entity);\n            return obj;\n        }, {});\n    });\n};\n"
  },
  {
    "__docId__": 80,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "relationFetch",
    "memberof": "src/context/index.js",
    "longname": "src/context/index.js~relationFetch",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context",
    "importStyle": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Context",
    "memberof": "src/context/index.js",
    "longname": "src/context/index.js~Context",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context",
    "importStyle": "Context",
    "description": " The context is a wrapper for the schema and connection.\n\n The major expost of the entire module.\n\n Apart from it's direct methods, every {@link Entity} in the {@link Schema} has a\n property on this object, which has the methods documented in {@link Context$Entity}.",
    "lineNumber": 39,
    "interface": false
  },
  {
    "__docId__": 82,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#constructor",
    "access": null,
    "description": "",
    "lineNumber": 46,
    "params": [
      {
        "nullable": null,
        "types": [
          "Connection",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "connectionSpec",
        "description": "This should be an `hiro-graph-client` `Connection` object,\n                                             or the constructor args to create one."
      },
      {
        "nullable": null,
        "types": [
          "Schema",
          "Array"
        ],
        "spread": false,
        "optional": false,
        "name": "schemaSpec",
        "description": "This should be a {@link Schema} or the constructor args to create one."
      },
      {
        "nullable": true,
        "types": [
          "Map"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "new&nbsp;Map()",
        "defaultRaw": "new&nbsp;Map()",
        "name": "cache",
        "description": "The vertex cache. Any object satisfying the `Map` interface should be OK."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 83,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_connection",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#_connection",
    "access": null,
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_schema",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#_schema",
    "access": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_cache",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#_cache",
    "access": null,
    "description": null,
    "lineNumber": 59,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_log",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#_log",
    "access": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "me",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#me",
    "access": null,
    "description": " This returns the vertex from the owner of the access token in use.",
    "lineNumber": 71,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 88,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getConnection",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#getConnection",
    "access": null,
    "description": "Get's the underlying GraphIT connection.",
    "lineNumber": 81,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Connection"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 89,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setCache",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#setCache",
    "access": null,
    "description": "Exchange the current cache for a new one.\n\nYou likely want to do this early on, before\nany entries have gone in.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "Map"
        ],
        "spread": false,
        "optional": false,
        "name": "cache",
        "description": "the new cache to use. Only needs to satisfy the `Map` interface, not actually be a `Map`"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 90,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_cache",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#_cache",
    "access": null,
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 91,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "findOne",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#findOne",
    "access": null,
    "description": " On the Context itself, this is an `un-typed` query for a single vertex.\n\n i.e. will search all entity types and return any one of them.",
    "lineNumber": 106,
    "params": [
      {
        "nullable": null,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the lucene query to perform"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "the options to pass on to the query {@todo document these}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the first vertex found or an error"
    },
    "generator": false
  },
  {
    "__docId__": 92,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "findById",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#findById",
    "access": null,
    "description": " On the Context itself, this is an `un-typed` query by id only\n\n i.e. will search all entity types for the given id or array of ids.",
    "lineNumber": 118,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "idOrIds",
        "description": "the id or array of ids to fetch"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "the options to pass on to the query {@todo document these}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": "the vertex/vertices found or an error"
    },
    "generator": false
  },
  {
    "__docId__": 93,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "find",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#find",
    "access": null,
    "description": " On the Context itself, this is an `un-typed` query.\n\n i.e. will search all entity types and return any of them.",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the lucene query to perform"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "the options to pass on to the query {@todo document these}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": "the first vertex found or an error"
    },
    "generator": false
  },
  {
    "__docId__": 94,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "search",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#search",
    "access": null,
    "description": " On the Context itself, this is an `un-typed` search.\n\n i.e. will search all entity types and return any of them.",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the search term or search definition."
      },
      {
        "nullable": null,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "filter",
        "description": "the lucene query to further restrict the results"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "the options to pass on to the query {@todo document these}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": "the first vertex found or an error"
    },
    "generator": false
  },
  {
    "__docId__": 95,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "delete",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#delete",
    "access": null,
    "description": " Deletes a vertex by id.",
    "lineNumber": 155,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "vertexId",
        "description": "the id of the vertex to delete"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "the options to pass on to the query {@todo document these}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the vertex (marked as deleted)"
    },
    "generator": false
  },
  {
    "__docId__": 96,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "gremlin",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#gremlin",
    "access": null,
    "description": " Create A Gremlin Query Builder with Context.",
    "lineNumber": 165,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "initialQuery",
        "description": "the starting point for the new query."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "a context aware gremlin query builder (e.g. `query.execute()` will work)"
    },
    "generator": false
  },
  {
    "__docId__": 97,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchCount",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#fetchCount",
    "access": null,
    "description": " Passthrough a count fetch in a promise",
    "examples": [
      " context.find({}).then(context.fetchCounts([\"related\"]));"
    ],
    "lineNumber": 180,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the relations to query for. These should match valid relation names on the entities passed in."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options to pass through to the underlying call"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(items: OneOrMoreVertices): Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": "returns a function which will call `fetchCount(relations, options)` on each input"
    },
    "generator": false
  },
  {
    "__docId__": 98,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchIds",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#fetchIds",
    "access": null,
    "description": " Passthrough a id fetch in a promise",
    "examples": [
      " context.find({}).then(context.fetchIds([\"related\"]));"
    ],
    "lineNumber": 195,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the relations to query for. These should match valid relation names on the entities passed in."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options to pass through to the underlying call"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(items: OneOrMoreVertices): Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": "returns a function which will call `fetchIds(relations, options)` on each input"
    },
    "generator": false
  },
  {
    "__docId__": 99,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchVertices",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#fetchVertices",
    "access": null,
    "description": " Passthrough a vertex fetch in a promise",
    "examples": [
      " context.find({}).then(context.fetchVertices([\"related\"]));"
    ],
    "lineNumber": 210,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the relations to query for. These should match valid relation names on the entities passed in."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "options to pass through to the underlying call"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "function(items: OneOrMoreVertices): Promise<OneOrMoreVertices>"
      ],
      "spread": false,
      "description": "returns a function which will call `fetchVertices(relations, options)` on each input"
    },
    "generator": false
  },
  {
    "__docId__": 100,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getEntity",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#getEntity",
    "access": null,
    "description": " Fetch an entity from the schema.",
    "lineNumber": 220,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the name of the entity, can be the application name, or the OGIT name"
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Entity"
      ],
      "spread": false,
      "description": "the entity if found."
    },
    "generator": false
  },
  {
    "__docId__": 101,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "remove",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#remove",
    "access": null,
    "description": " Manually remove an item from the ORM cache.",
    "lineNumber": 230,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "vertexId",
        "description": "the ID of the vertex to drop."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": "no return value"
    },
    "generator": false
  },
  {
    "__docId__": 102,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "insertRaw",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#insertRaw",
    "access": null,
    "description": " Manually give the orm data, raw from Graphit\n\n Useful when you have have to bypass the regular system, or have nodes stored somewhere else.",
    "lineNumber": 242,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "rawData",
        "description": "the raw GraphIT vertex data;"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GraphVertex"
      ],
      "spread": false,
      "description": "the inserted vertex"
    },
    "generator": false
  },
  {
    "__docId__": 103,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "insert",
    "memberof": "src/context/index.js~Context",
    "longname": "src/context/index.js~Context#insert",
    "access": null,
    "description": " Manually give the orm data, in application format",
    "lineNumber": 254,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "appData",
        "description": "the application vertex data object"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GraphVertex"
      ],
      "spread": false,
      "description": "the inserted vertex"
    },
    "generator": false
  },
  {
    "__docId__": 104,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mixinMethods",
    "memberof": "src/context/index.js",
    "longname": "src/context/index.js~mixinMethods",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context",
    "importStyle": null,
    "description": null,
    "lineNumber": 259,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 105,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mixinMethodNames",
    "memberof": "src/context/index.js",
    "longname": "src/context/index.js~mixinMethodNames",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context",
    "importStyle": null,
    "description": null,
    "lineNumber": 276,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 106,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapEntityShortcuts",
    "memberof": "src/context/index.js",
    "longname": "src/context/index.js~mapEntityShortcuts",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context",
    "importStyle": null,
    "description": null,
    "lineNumber": 281,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 107,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/context/relations.js",
    "memberof": null,
    "longname": "src/context/relations.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  This is where the crazy queries for relation data are handled.\n */\nimport { mapPromiseIfArray } from \"../utils\";\nimport { vertexize } from \"./graph\";\n\nfunction createRelationMap(relations, keyFn = () => []) {\n    return relations.reduce((obj, rel) => (obj[rel] = keyFn(rel), obj), {});\n}\n\n//returns an object { relation: [ obj, ... ] }\n/**\n * @ignore - we don't need docs about this. they are internal exports\n */\nexport function fetchVertices(ctx, entity) {\n    return relationQuery(ctx, entity, (relations, gremlin, options) => {\n        //get the nodes as well\n        const query = gremlin.copySplit([\n            //this is the edge map\n            _ => _.groupBy(\"$_alias\", \"ogit/_id\"),\n            //and this is all the nodes\n            _ => _.dedup()\n        ]);\n        if (options.returnQuery) {\n            return query;\n        }\n        return mapPromiseIfArray(vertex => {\n            return query.executeInContext(ctx, vertex._id, Object.assign({ raw: true }, options))\n                .then(([edgeMap, ...raw]) => {\n                    //patch them together again\n                    return vertexize(ctx)(raw)\n                        .then(vertices => {\n                            const vertexMap = vertices.reduce((o, v) => (o[v._id] = v, o), {});\n                            return createRelationMap(relations, key => {\n                                if (edgeMap[key]) {\n                                    return edgeMap[key].map(id => vertexMap[id]);\n                                }\n                                return [];\n                            });\n                        });\n                });\n        });\n    });\n}\n\n//returns an object { relation: [ id, id, ... ] }\n/**\n * @ignore - we don't need docs about this. they are internal exports\n */\nexport function fetchIds(ctx, entity) {\n    return relationQuery(ctx, entity, (relations, gremlin, options) => {\n        //count the aliases.\n        const query = gremlin.groupBy(\"$_alias\", \"ogit/_id\");\n        if (options.returnQuery) {\n            return query;\n        }\n        return mapPromiseIfArray(vertex => {\n            return query\n                .executeInContext(ctx, vertex._id, Object.assign({ raw: true }, options))\n                .then(([info]) => createRelationMap(relations, key => info[key] || []));\n        });\n    });\n}\n\n//returns an object { relation: X }\n/**\n * @ignore - we don't need docs about this. they are internal exports\n */\nexport function fetchCount(ctx, entity) {\n    return relationQuery(ctx, entity, (relations, gremlin, options) => {\n        //count the aliases.\n        const query = gremlin.groupBy(\"$_alias\");\n        return mapPromiseIfArray(vertex => {\n            return query\n                .executeInContext(ctx, vertex._id, Object.assign({ raw: true }, options))\n                .then(([info]) => createRelationMap(relations, key => info[key] || 0));\n        });\n    });\n}\n\n//expose this to allow getting the query for a relation\n/**\n * @ignore - we don't need docs about this. they are internal exports\n */\nexport function getRelationQuery(entity, relation, options = {}) {\n    return relationQueryGenerator(entity, options)(relation);\n}\n\n//creates a relation query and returns it.\n/**\n * @ignore - we don't need docs about this. they are internal exports\n */\nfunction relationQuery(ctx, entity, finaliser) {\n    const getQuery = relationQueryGenerator(entity, { withAlias: \"$_alias\" });\n    return (relations, options = {}) => {\n        const queries = relations.map(getQuery);\n\n        //now we have an array.\n        const gremlin = ctx.gremlin();\n        if (queries.length === 1) {\n            queries[0](gremlin); //apply directly.\n        } else {\n            gremlin.copySplit(queries);\n        }\n        //finish up indiviually\n        return finaliser(relations, gremlin, options);\n    };\n}\n\n// The complex one (although simplified and generalised from the TabTab original...)\n// This function creates a gremlin query that traverses according to the defined\n// relation in the schema.\n/**\n * @ignore - we don't need docs about this. they are internal exports\n */\nexport function relationQueryGenerator(entity, { withAlias = false }) {\n    return relation => {\n        const { alias, hops } = entity.relation(relation);\n        return gremlin => {\n            hops.forEach(({ verb, direction, filter, vertices }) => {\n                const inbound = direction === \"in\";\n                const firstEdge = inbound ? \"inE\" : \"outE\";\n                const secondEdge = inbound ? \"outV\" : \"inV\";\n                const edgeTypeProp = inbound ? \"ogit/_out-type\" : \"ogit/_in-type\";\n\n                //traverse the edge by verb label.\n                gremlin[firstEdge](verb);\n\n                //now there are three paths dependent on whether there is zero, only one or multiple vertex type(s).\n                //if so we can optimise.\n                switch (true) {\n                    case (vertices.length === 0):\n                        //no node type specified, could be anything.\n                        break;\n                    case (vertices.length === 1):\n                        //only a single vertextype.\n                        gremlin.has(edgeTypeProp, vertices[0]);\n                        break;\n                    default:\n                        //many possible nodes, we use T.in to filter.\n                        gremlin.has(edgeTypeProp, \"T.in\", vertices);\n                }\n\n                //now out to the vertices\n                gremlin[secondEdge]();\n\n                //now we filter if there is one.\n                if (filter) {\n                    gremlin.has(filter);\n                }\n            });\n\n            //now we have the vertices, if we were going to add an alias, here it comes.\n            if (withAlias) {\n                gremlin.addTempProp(withAlias, alias);\n            }\n\n            return gremlin;\n        };\n    };\n}\n"
  },
  {
    "__docId__": 108,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createRelationMap",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~createRelationMap",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "params": [
      {
        "name": "relations",
        "types": [
          "*"
        ]
      },
      {
        "name": "keyFn",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 109,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "fetchVertices",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~fetchVertices",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": "{fetchVertices}",
    "description": "",
    "lineNumber": 15,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 110,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "fetchIds",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~fetchIds",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": "{fetchIds}",
    "description": "",
    "lineNumber": 50,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 111,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "fetchCount",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~fetchCount",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": "{fetchCount}",
    "description": "",
    "lineNumber": 69,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 112,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "getRelationQuery",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~getRelationQuery",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": "{getRelationQuery}",
    "description": "",
    "lineNumber": 85,
    "ignore": true,
    "params": [
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "relation",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 113,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "relationQuery",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~relationQuery",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": null,
    "description": "",
    "lineNumber": 93,
    "ignore": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "finaliser",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 114,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "relationQueryGenerator",
    "memberof": "src/context/relations.js",
    "longname": "src/context/relations.js~relationQueryGenerator",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/context/relations",
    "importStyle": "{relationQueryGenerator}",
    "description": "",
    "lineNumber": 116,
    "ignore": true,
    "params": [
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"withAlias\": *}"
        ],
        "defaultRaw": {
          "withAlias": null
        },
        "defaultValue": "{\"withAlias\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 115,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/gremlin/index.js",
    "memberof": null,
    "longname": "src/gremlin/index.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  Schema aware Gremlin wrapper.\n */\nimport { gremlin } from \"../context/graph\";\n\n//This is a placeholder until \"parse\" is designed and implemented\n/**\n *  @ignore - no docs.\n */\nexport default function parseGremlin(/*query = {}, entity*/) {\n    throw new Error(\"@TODO: need to figure out a good API for schema aware gremlin queries. Then we can implement\");\n    //Not sure this is needed with entity.encode();\n}\n\n/**\n *  Create a new query builder\n *\n *  @param {string|GremlinQueryBuilder} initialQuery - a starting point query\n *  @param {Context} context - a {@link Context} object, allowing this gremlin query to `execute` itself.\n *  @return {GremlinQueryBuilder} - a new query builder\n */\nexport function queryBuilder(initialQuery, context) {\n    return new GremlinQueryBuilder(initialQuery, context);\n}\n\n/**\n *  A simple gremlin query builder object.\n *\n *  Provides a convenience for having to produce the queries by hand,\n *  and escapes the terms correctly.\n */\nexport class GremlinQueryBuilder {\n\n    /**\n     *  @param GremlinQueryBuilder} initialQuery - An initial query to base this one on.\n     *  @param {?Context} context - a {@link Context} object, allowing this gremlin query to `execute` itself.\n     *  @return {GremlinQueryBuilder} - a new query builder\n     */\n    constructor(initialQuery = false, context) {\n        this._ctx = context;\n        this._stack = [];\n        this._query = false;\n        if (initialQuery) {\n            this._stack.push(initialQuery);\n            this._query = initialQuery;\n        }\n    }\n\n    /**\n     * Execute a gremlin query against the internal context.\n     *\n     * Will throw an error if no context is present on this instance\n     *\n     *  @param {string} rootVertexId - the Root vertex to initiate this query\n     *  @param {object} [options={}] - further options to pass to the GraphIT connection\n     *  @retruen {Promise<any>} - A promise for the results, which could be anything\n     */\n    execute(rootVertexId, options = {}) {\n        return gremlin(this._ctx, rootVertexId, this.toString(), options);\n    }\n\n    /**\n     *  Execute the query in the given context\n     *\n     *  Similiar to `.execute` but uses the give context, not the internal one.\n     *\n     *  @param {Context} ctx - the Graph Context to use for this query\n     *  @param {string} rootVertexId - the Root vertex to initiate this query\n     *  @param {object} [options={}] - further options to pass to the GraphIT connection\n     *  @retruen {Promise<any>} - A promise for the results, which could be anything\n     */\n    executeInContext(ctx, rootVertexId, options = {}) {\n        return gremlin(ctx, rootVertexId, this.toString(), options);\n    }\n\n    /**\n     *  Query along a Schema-defined Relation\n     *\n     *  @param {string} type - the Schema type name for the entity the relation belongs to\n     *  @param {Array<string>} relations - the names of the relations to generate a gremlin query for\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    relation(type, relations) {\n        if (!this._ctx) {\n            throw new Error(\"Cannot use gremlin `relation` without context\");\n        }\n        return this._ctx[type].relationQuery(relations)(this);\n    }\n\n    /**\n     * Turns the query into a string to send to GraphIT\n     *\n     * We cache the string form, so you *must* always use \"raw\" to update the stack\n     * even from inside the class methods.\n     *\n     *  @return {string} the string representation of the query\n     */\n    toString() {\n        if (this._query === false) {\n            this._query = this._stack.filter(Boolean).join(\".\");\n        }\n        return this._query;\n    }\n\n    /**\n     *  Push a raw query segment onto the internal stack\n     *\n     *  This is used by all internal methods and adds data\n     *  to the current query.\n     *\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    raw(query) {\n        this._stack.push(query);\n        this._query = false;\n        return this;\n    }\n\n    /**\n     *  Append to the last chunk in the stack,\n     *\n     *  This is used for the very rare instances where you\n     *  need to add directly to the last element in the stack\n     *  rather than adding a new element (which would be `.` seperated)\n     *\n     *  The example is a limit clause which appends `[0..1]` directly to\n     *  the current pipeline.\n     *\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    append(query) {\n        const chunk = this._stack.pop() + query;\n        return this.raw(chunk);\n    }\n\n    /**\n     *  Apply one or more transforms to the query\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#transform-1\n     *\n     *  @param {object.<string, GremlinBranch>|Array<GremlinBranch>} transforms - the transformations to make\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    transform(transforms) {\n        let branches;\n        const brancher = createBrancher(\"it\", this._ctx);\n        if (Array.isArray(transforms)) {\n            //closure to remove the \"index\" argument\n            branches = transforms.map(value => brancher(value));\n        } else {\n            branches = Object.keys(transforms).map(key => brancher(transforms[key], key));\n        }\n        return this.raw(`transform{[${branches.join(\",\")}]}`);\n    }\n\n    /**\n     *  Split the pipeline into multiple (and merge back)\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#copysplit\n     *\n     *  @param {Array<GremlinBranch>} paths - the transformations to make\n     *  @param {string} [mergeType=fairMerge] - the method of merging the results.\n                            either `fairMerge` which is one of each branch in turn\n                            or `exhaustMerge` which exhausts each branch in turn\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    copySplit(paths, mergeType = \"fairMerge\") {\n        if (mergeType !== \"fairMerge\" && mergeType !== \"exhaustMerge\") {\n            throw new Error(\"invalid copySplit merge. should be `fairMerge` or `exhaustMerge`\");\n        }\n        const brancher = createBrancher(\"_()\", this._ctx);\n        const branches = paths.map(value => brancher(value));\n        return this.raw(`copySplit(${branches.join(\",\")}).${mergeType}`);\n    }\n\n    /**\n     *  Or conditions are handle with a branching method.\n     *\n     *  Each condition is considered and any one pass means the\n     *  object continues through the pipeline.\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#or\n     *\n     *  @param {Array<GremlinBranch>} conditions - the array of possible conditions\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    or(conditions) {\n        const brancher = createBrancher(\"_()\", this._ctx);\n        const branches = conditions.map(value => brancher(value));\n        return this.raw(`or(${branches.join(\",\")})`);\n    }\n\n    /**\n     *  Apply a deduplication filter\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#dedup\n     *\n     *  @param {string} [prop=ogit/_id] - the property to perform the deduplication on.\n                            You will almost always want the default (`ogit/_id`).\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    dedup(prop = \"ogit/_id\") {\n        return this.raw(`dedup{it.getProperty(${quote(prop)})}`);\n    }\n\n    /**\n     *  Restrict results to a subset of the pipeline\n     *\n     *  NB. `start` zero based an inclusive, `finish` is absolute (not relative to start) and inclusive.\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#ij\n     *\n     *  @param {number} start - where to begin from\n     *  @param {number} finish - where to end\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    limit(start, finish) {\n         //this needs to be merged directly onto the last element of the query!\n        //but only after we have provided the clause to filter deleted elements.\n        //otherwise this limiting will no do what we expect.\n        //@TODO check in GraphIT as to whether this is still needed...\n        this.hasNot(\"ogit/_is-deleted\", true);\n        //now append the limit\n        return this.append(`[${start}..${finish}]`);\n    }\n\n    /**\n     *  Re-order the pipeline\n     *\n     *  Note that in GraphIT almost everything is a string, so ordering is\n     *  lexical. (most codecs created by {@link createCodec} respect lexical ordering)\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#order\n     *\n     *  @param {string} prop - the property to order by\n     *  @param {string} dir - the direction of the ordering, `asc` or `desc`.\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    order(prop, dir = \"desc\") {\n        const isAsc = dir === \"asc\";\n        const getProp = `.getProperty(${quote(prop)})`;\n        const [first, second] = isAsc ? [\"a\", \"b\"] : [\"b\", \"a\"];\n        return this.raw(`order{it.${first}${getProp} <=> it.${second}${getProp}}`);\n    }\n\n    /**\n     *  Filter the pipeline with a closure.\n     *\n     *  **NB there is currently no validation of the input**\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#filter-1\n     *\n     *  @param {string} condition - the string version of the closure for filtering the pipeline\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    filter(condition) {\n        //NB no validation is done here!\n        //perhap we could improve with\n        // filter(subjectGremlinQuery, comparator, object)\n        // e.g filter(_ => _.getProperty(\"age\"), \">\", 29);\n        return this.raw(`filter{${condition}}`);\n    }\n\n    /**\n     *  Shorthand for a transform that adds a static temporary property to each result in the pipeline\n     *\n     *  @param {string} name - the temporary property name (must start with `$_`)\n     *  @param {string} value - the static value to add to each result\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    addTempProp(name, value) {\n        ensureTemporaryPropNameOK(name);\n        this.raw(`transform{it.${name}=${quote(value)};it}`);\n    }\n    /**\n     *  Shorthand for a transform that adds a dynamic temporary property to each result in the pipeline\n     *\n     *  @param {string} name - the temporary property name (must start with `$_`)\n     *  @param {string|GremlinBranch} query - the query to produce a value to add to each result.\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    addComputedProp(name, query) {\n        ensureTemporaryPropNameOK(name);\n        const subQuery = createBrancher(\"it\")(query);\n        return this.raw(`transform{it.${name}=${subQuery};it}`);\n    }\n\n    /**\n     *  Group results by given property's value\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#groupby\n     *\n     *  @param {string} groupingProp - the property to group by.\n     *  @param {string} resultProp - the property to use in the groups - probably `ogit/_id`\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    groupBy(groupingProp, resultProp = false) {\n        const prop = (groupingProp === \"label\") ? groupingProp : `getProperty(${quote(groupingProp)})`;\n        const resultStanza = resultProp ? `it.getProperty(${quote(resultProp)})` : \"it\";\n        return this.raw(`groupBy{it.${prop}}{${resultStanza}}.cap`);\n    }\n\n    /**\n     *  Count results grouped by given property's value\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#groupby\n     *\n     *  @param {string} groupingProp - the property to group by.\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    groupCount(groupingProp) {\n        const prop = (groupingProp === \"label\") ? groupingProp : `getProperty(${quote(groupingProp)})`;\n        return this.raw(`groupCount{it.${prop}}.cap`);\n    }\n\n    /**\n     *  Traverse to incoming edges\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#ine\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    inE(...args) {\n        return this.raw(methodCall(\"inE\", args));\n    }\n\n    /**\n     *  Traverse to outbound edges\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#oute\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    outE(...args) {\n        return this.raw(methodCall(\"outE\", args));\n    }\n\n    /**\n     *  Traverse to edges in both directions\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#bothe\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    bothE(...args) {\n        return this.raw(methodCall(\"bothE\", args));\n    }\n\n    /**\n     *  Traverse to incoming vertices\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#inv\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    inV(...args) {\n        return this.raw(methodCall(\"inV\", args));\n    }\n\n    /**\n     *  Traverse to outbound vertices\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#outv\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    outV(...args) {\n        return this.raw(methodCall(\"outV\", args));\n    }\n\n    /**\n     *  Traverse to vertices in both directions\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#bothv\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    bothV(...args) {\n        return this.raw(methodCall(\"bothV\", args));\n    }\n\n    /**\n     *  Traverse to vertices along inbound edges\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#in\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    in(...args) {\n        return this.raw(methodCall(\"in\", args));\n    }\n    /**\n     *  Traverse to vertices along outbound edges\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#out\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    out(...args) {\n        return this.raw(methodCall(\"out\", args));\n    }\n\n    /**\n     *  Traverse to vertices along edges in either direction\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#both\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    both(...args) {\n        return this.raw(methodCall(\"both\", args));\n    }\n\n    /**\n     *  pluck a property value from each element in the pipeline\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#key\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    getProperty(...args) {\n        return this.raw(methodCall(\"getProperty\", args));\n    }\n\n    /**\n     *  Count the results in the pipeline\n     *\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    count(...args) {\n        return this.raw(methodCall(\"count\", args));\n    }\n\n    /**\n     *  Mark a pipeline position for later back-filtering\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#as\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    as(...args) {\n        return this.raw(methodCall(\"as\", args));\n    }\n\n    /**\n     *  Back-filter to a named step or by a number of steps.\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#back\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    back(...args) {\n        return this.raw(methodCall(\"back\", args));\n    }\n\n    /**\n     *  Randomize pipeline output order\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#shuffle\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    shuffle(...args) {\n        return this.raw(methodCall(\"shuffle\", args));\n    }\n\n    /**\n     *  Filter the pipeline to object which match the pattern\n     *\n     *  The argument here can be an object of \"prop\" => \"value\" (which you\n     *  can encode with a {@see Codec})\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#has\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    has(...args) {\n        return objectMethodCall(this, \"has\", args);\n    }\n\n    /**\n     *  Filter the pipeline to object which **don't** match the pattern\n     *\n     *  The argument here can be an object of \"prop\" => \"value\" (which you\n     *  can encode with a {@see Codec})\n     *\n     *  @see http://gremlindocs.spmallette.documentup.com/#hasnot\n     *  @return {GremlinQueryBuilder} - the same object (chainable)\n     */\n    hasNot(...args) {\n        return objectMethodCall(this, \"hasNot\", args);\n    }\n}\n\n//helper to validate temporary property name\nconst ensureTemporaryPropNameOK = name => {\n    if (name.indexOf(\"$_\") !== 0) {\n        throw new Error(`Gremlin temporary properties must start with $_, given: ${name}`);\n    }\n};\n\n//creates a branched structure with subQueries\nconst createBrancher = (prefix, ctx) => (value, key = false) => {\n    const subQuery = new GremlinQueryBuilder(prefix, ctx);\n    //if a string, assume a fixed query\n    if (typeof value === \"string\") {\n        subQuery.raw(value);\n    } else {\n        value(subQuery);\n    }\n    return (key ? key + \":\" : \"\") + subQuery;\n};\n\n//quote a value for use in a gremlin function argument.\nconst quote = value => `\"${value.replace(/\"/g, `\\\\\"`).replace(/\\$/g, `\\\\$`)}\"`;\n\nconst formatArgs = args => args.map(value => {\n    if (value === true || value === false) {\n        //don't quote;\n        return value ? \"true\" : \"false\";\n    }\n    if (Array.isArray(value)) {\n        //OK, an array of values need quoting and adding surrounded by\n        //square brackets\n        return `[${formatArgs(value).join(\",\")}]`;\n    }\n    //after this cast to string\n    const str = \"\" + value;\n\n    if (/^T\\.[a-z]+/.test(str)) {\n        //this is an identifier used for comparison operators.\n        //do not quote.\n        return str;\n    }\n    if (/^[0-9]+(\\.[0-9]*)?[lf]?$/.test(str)) {\n        //this is a java int/long/float, return as is.\n        //NB this is not the only way to denote this, but\n        //the only format *we* accept.\n        return str;\n    }\n    //otherwise just quote.\n    return quote(str);\n});\n\n//a simple method call to string.\nconst methodCall = (method, args = []) => {\n    return `${method}(${formatArgs(args).join(\",\")})`;\n};\n\nconst objectMethodCall = (instance, method, args = []) => {\n    const first = args[0];\n    if (typeof first === \"object\") {\n        Object.keys(first).forEach(key => {\n            //only single arguments in this form.\n            instance.raw(methodCall(method, [key, first[key]]));\n        });\n        return instance;\n    }\n    return instance.raw(methodCall(method, args));\n};\n"
  },
  {
    "__docId__": 116,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseGremlin",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~parseGremlin",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": "parseGremlin",
    "description": "",
    "lineNumber": 10,
    "ignore": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 117,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "queryBuilder",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~queryBuilder",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": "{queryBuilder}",
    "description": " Create a new query builder",
    "lineNumber": 22,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "GremlinQueryBuilder"
        ],
        "spread": false,
        "optional": false,
        "name": "initialQuery",
        "description": "a starting point query"
      },
      {
        "nullable": null,
        "types": [
          "Context"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "a {@link Context} object, allowing this gremlin query to `execute` itself."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "a new query builder"
    },
    "generator": false
  },
  {
    "__docId__": 118,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "GremlinQueryBuilder",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": "{GremlinQueryBuilder}",
    "description": " A simple gremlin query builder object.\n\n Provides a convenience for having to produce the queries by hand,\n and escapes the terms correctly.",
    "lineNumber": 32,
    "interface": false
  },
  {
    "__docId__": 119,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#constructor",
    "access": null,
    "description": "",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "GremlinQueryBuilder}",
        "description": "initialQuery - An initial query to base this one on."
      },
      {
        "nullable": true,
        "types": [
          "Context"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "a {@link Context} object, allowing this gremlin query to `execute` itself."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "a new query builder"
    },
    "generator": false
  },
  {
    "__docId__": 120,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_ctx",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#_ctx",
    "access": null,
    "description": null,
    "lineNumber": 40,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 121,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_stack",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#_stack",
    "access": null,
    "description": null,
    "lineNumber": 41,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 122,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_query",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#_query",
    "access": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_query",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#_query",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "execute",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#execute",
    "access": null,
    "description": "Execute a gremlin query against the internal context.\n\nWill throw an error if no context is present on this instance",
    "lineNumber": 58,
    "unknown": [
      {
        "tagName": "@retruen",
        "tagValue": "{Promise<any>} - A promise for the results, which could be anything"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootVertexId",
        "description": "the Root vertex to initiate this query"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "further options to pass to the GraphIT connection"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 125,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "executeInContext",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#executeInContext",
    "access": null,
    "description": " Execute the query in the given context\n\n Similiar to `.execute` but uses the give context, not the internal one.",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@retruen",
        "tagValue": "{Promise<any>} - A promise for the results, which could be anything"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Context"
        ],
        "spread": false,
        "optional": false,
        "name": "ctx",
        "description": "the Graph Context to use for this query"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootVertexId",
        "description": "the Root vertex to initiate this query"
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "options",
        "description": "further options to pass to the GraphIT connection"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 126,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "relation",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#relation",
    "access": null,
    "description": " Query along a Schema-defined Relation",
    "lineNumber": 83,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "type",
        "description": "the Schema type name for the entity the relation belongs to"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the names of the relations to generate a gremlin query for"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 127,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toString",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#toString",
    "access": null,
    "description": "Turns the query into a string to send to GraphIT\n\nWe cache the string form, so you *must* always use \"raw\" to update the stack\neven from inside the class methods.",
    "lineNumber": 98,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "the string representation of the query"
    },
    "generator": false
  },
  {
    "__docId__": 128,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_query",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#_query",
    "access": null,
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 129,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "raw",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#raw",
    "access": null,
    "description": " Push a raw query segment onto the internal stack\n\n This is used by all internal methods and adds data\n to the current query.",
    "lineNumber": 113,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 130,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_query",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#_query",
    "access": null,
    "description": null,
    "lineNumber": 115,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 131,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "append",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#append",
    "access": null,
    "description": " Append to the last chunk in the stack,\n\n This is used for the very rare instances where you\n need to add directly to the last element in the stack\n rather than adding a new element (which would be `.` seperated)\n\n The example is a limit clause which appends `[0..1]` directly to\n the current pipeline.",
    "lineNumber": 131,
    "params": [
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 132,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "transform",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#transform",
    "access": null,
    "description": " Apply one or more transforms to the query",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#transform-1"
    ],
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "object.<string, GremlinBranch>",
          "Array<GremlinBranch>"
        ],
        "spread": false,
        "optional": false,
        "name": "transforms",
        "description": "the transformations to make"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 133,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "copySplit",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#copySplit",
    "access": null,
    "description": " Split the pipeline into multiple (and merge back)",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#copysplit"
    ],
    "lineNumber": 167,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<GremlinBranch>"
        ],
        "spread": false,
        "optional": false,
        "name": "paths",
        "description": "the transformations to make"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "fairMerge",
        "defaultRaw": "fairMerge",
        "name": "mergeType",
        "description": "the method of merging the results.\neither `fairMerge` which is one of each branch in turn\nor `exhaustMerge` which exhausts each branch in turn"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 134,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "or",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#or",
    "access": null,
    "description": " Or conditions are handle with a branching method.\n\n Each condition is considered and any one pass means the\n object continues through the pipeline.",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#or"
    ],
    "lineNumber": 187,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<GremlinBranch>"
        ],
        "spread": false,
        "optional": false,
        "name": "conditions",
        "description": "the array of possible conditions"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 135,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "dedup",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#dedup",
    "access": null,
    "description": " Apply a deduplication filter",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#dedup"
    ],
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "ogit/_id",
        "defaultRaw": "ogit/_id",
        "name": "prop",
        "description": "the property to perform the deduplication on.\nYou will almost always want the default (`ogit/_id`)."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 136,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "limit",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#limit",
    "access": null,
    "description": " Restrict results to a subset of the pipeline\n\n NB. `start` zero based an inclusive, `finish` is absolute (not relative to start) and inclusive.",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#ij"
    ],
    "lineNumber": 217,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "start",
        "description": "where to begin from"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "finish",
        "description": "where to end"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 137,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "order",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#order",
    "access": null,
    "description": " Re-order the pipeline\n\n Note that in GraphIT almost everything is a string, so ordering is\n lexical. (most codecs created by {@link createCodec} respect lexical ordering)",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#order"
    ],
    "lineNumber": 239,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": "the property to order by"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "dir",
        "description": "the direction of the ordering, `asc` or `desc`."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 138,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "filter",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#filter",
    "access": null,
    "description": " Filter the pipeline with a closure.\n\n **NB there is currently no validation of the input**",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#filter-1"
    ],
    "lineNumber": 256,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "condition",
        "description": "the string version of the closure for filtering the pipeline"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 139,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addTempProp",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#addTempProp",
    "access": null,
    "description": " Shorthand for a transform that adds a static temporary property to each result in the pipeline",
    "lineNumber": 271,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the temporary property name (must start with `$_`)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the static value to add to each result"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 140,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "addComputedProp",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#addComputedProp",
    "access": null,
    "description": " Shorthand for a transform that adds a dynamic temporary property to each result in the pipeline",
    "lineNumber": 282,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "the temporary property name (must start with `$_`)"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "GremlinBranch"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to produce a value to add to each result."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 141,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "groupBy",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#groupBy",
    "access": null,
    "description": " Group results by given property's value",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#groupby"
    ],
    "lineNumber": 297,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "groupingProp",
        "description": "the property to group by."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "resultProp",
        "description": "the property to use in the groups - probably `ogit/_id`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 142,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "groupCount",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#groupCount",
    "access": null,
    "description": " Count results grouped by given property's value",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#groupby"
    ],
    "lineNumber": 311,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "groupingProp",
        "description": "the property to group by."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 143,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "inE",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#inE",
    "access": null,
    "description": " Traverse to incoming edges",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#ine"
    ],
    "lineNumber": 322,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 144,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "outE",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#outE",
    "access": null,
    "description": " Traverse to outbound edges",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#oute"
    ],
    "lineNumber": 332,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 145,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "bothE",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#bothE",
    "access": null,
    "description": " Traverse to edges in both directions",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#bothe"
    ],
    "lineNumber": 342,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 146,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "inV",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#inV",
    "access": null,
    "description": " Traverse to incoming vertices",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#inv"
    ],
    "lineNumber": 352,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 147,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "outV",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#outV",
    "access": null,
    "description": " Traverse to outbound vertices",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#outv"
    ],
    "lineNumber": 362,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 148,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "bothV",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#bothV",
    "access": null,
    "description": " Traverse to vertices in both directions",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#bothv"
    ],
    "lineNumber": 372,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 149,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "in",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#in",
    "access": null,
    "description": " Traverse to vertices along inbound edges",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#in"
    ],
    "lineNumber": 382,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 150,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "out",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#out",
    "access": null,
    "description": " Traverse to vertices along outbound edges",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#out"
    ],
    "lineNumber": 391,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 151,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "both",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#both",
    "access": null,
    "description": " Traverse to vertices along edges in either direction",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#both"
    ],
    "lineNumber": 401,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 152,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getProperty",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#getProperty",
    "access": null,
    "description": " pluck a property value from each element in the pipeline",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#key"
    ],
    "lineNumber": 411,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 153,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "count",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#count",
    "access": null,
    "description": " Count the results in the pipeline",
    "lineNumber": 420,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 154,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "as",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#as",
    "access": null,
    "description": " Mark a pipeline position for later back-filtering",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#as"
    ],
    "lineNumber": 430,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 155,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "back",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#back",
    "access": null,
    "description": " Back-filter to a named step or by a number of steps.",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#back"
    ],
    "lineNumber": 440,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 156,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "shuffle",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#shuffle",
    "access": null,
    "description": " Randomize pipeline output order",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#shuffle"
    ],
    "lineNumber": 450,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 157,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "has",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#has",
    "access": null,
    "description": " Filter the pipeline to object which match the pattern\n\n The argument here can be an object of \"prop\" => \"value\" (which you\n can encode with a {@see Codec})",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#has"
    ],
    "lineNumber": 463,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 158,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "hasNot",
    "memberof": "src/gremlin/index.js~GremlinQueryBuilder",
    "longname": "src/gremlin/index.js~GremlinQueryBuilder#hasNot",
    "access": null,
    "description": " Filter the pipeline to object which **don't** match the pattern\n\n The argument here can be an object of \"prop\" => \"value\" (which you\n can encode with a {@see Codec})",
    "see": [
      "http://gremlindocs.spmallette.documentup.com/#hasnot"
    ],
    "lineNumber": 476,
    "params": [
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GremlinQueryBuilder"
      ],
      "spread": false,
      "description": "the same object (chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 159,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "ensureTemporaryPropNameOK",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~ensureTemporaryPropNameOK",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": null,
    "description": null,
    "lineNumber": 482,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 160,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createBrancher",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~createBrancher",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": null,
    "description": null,
    "lineNumber": 489,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "quote",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~quote",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": null,
    "description": null,
    "lineNumber": 501,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 162,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "formatArgs",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~formatArgs",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": null,
    "description": null,
    "lineNumber": 503,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 163,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "methodCall",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~methodCall",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": null,
    "description": null,
    "lineNumber": 532,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 164,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "objectMethodCall",
    "memberof": "src/gremlin/index.js",
    "longname": "src/gremlin/index.js~objectMethodCall",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/gremlin",
    "importStyle": null,
    "description": null,
    "lineNumber": 536,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/index.js",
    "memberof": null,
    "longname": "src/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import Schema from \"./schema\";\nimport Context from \"./context\";\n\nexport { Schema, Context };\n"
  },
  {
    "__docId__": 166,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/lucene/index.js",
    "memberof": null,
    "longname": "src/lucene/index.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n *  Schema aware Lucene Wrapper\n */\nconst OP_NOT = \"-\";\nconst OP_MUST = \"+\";\nconst OP_CAN = \"\";\n\n/**\n *  The lucene class takes a Schema and creates a query parser.\n *\n *  This is super powerful, the guide to all the syntax options is in the documentation\n *  for the {@link LuceneQuery} type.\n *\n *  @param {?LuceneQuery} query - the query to parse\n *  @param {?Entity} entity - an optional schema entity to use to translate the keys and values\n *  @return {{ querystring: string, placeholders: object }} - the return value contains the string to be used\n *          as the query body and the placeholders to go with it (if any)\n */\nexport default function parseLucene(query = {}, entity) {\n    return createLuceneQuery(entity, query);\n}\n\n/**\n * Create a placeholder key\n */\nconst createPlaceholder = (placeholders, term) => {\n    placeholders.push(term);\n    return placeholderAliasInQuery(placeholders.length - 1);\n};\n\nconst placeholderAliasInQuery = i => `$ph_${i}`;\nconst placeholderKeyInRequest = i => `ph_${i}`;\n\n/**\n *  The initial context object for the query building\n */\nconst initialContext = entity => {\n    return {\n        querystring: \"\",\n        placeholders: [],\n        op: OP_MUST,\n        entity\n    };\n};\n\n/**\n * using the entity given, map the query object to a Lucene query string + placeholders.\n */\nfunction createLuceneQuery(entity, query) {\n    const context = initialContext(entity);\n    const querystring = createQuerySegment(context, normaliseQuery(query));\n    const parsed = {\n        querystring,\n        placeholders: context.placeholders.reduce((opts, placeholder, index) => {\n            opts[placeholderKeyInRequest(index)] = placeholder;\n            return opts;\n        }, {})\n    };\n    if (!entity.internal) {\n        //this is not an internal-only entity (i.e. a fake one that just translates\n        // ogit internal attributes. This means we should insert a \"ogit/_type\" filter.\n        parsed.querystring = `+${slashForward(\"ogit/_type\")}:${quote(entity.ogit)} ${parsed.querystring}`;\n    }\n    return parsed;\n}\n\n//turns a single value into an array if not already\nconst ensureArray = value => {\n    return Array.isArray(value) ? value : [value];\n};\n\n//the \"$\" keys which do not recurse\nconst noRecurseKeys = [\"$search\", \"$range\", \"$missing\"];\n\n//forces all properties to be arrays.\n//knows how to recurse and when not to.\nconst normaliseQuery = queryObject => {\n    return Object.keys(queryObject).map(key => {\n        const value = queryObject[key];\n        // console.log(\"key:\", key);\n        // console.log(\"value:\", value);\n        if (key[0] === \"$\" && noRecurseKeys.indexOf(key) === -1) {\n            //we should recurse\n            return { key, values: normaliseQuery(value) };\n        }\n        return { key, values: ensureArray(value) };\n    });\n};\n\n/**\n *  This is the recursive part that constructs the querystring from the\n *  query given.\n */\nfunction createQuerySegment(context, query) {\n//    console.log(\"segment\", query);\n    return query.map(({ key, values }) => {\n        //always make value an array\n        if (key[0] === \"$\") {\n            //special case!\n            return operators[key](context, values);\n        }\n        //default prop => values\n        return luceneTerm(context, key, values);\n    }).join(\" \");\n}\n\n//helper to flatten an array of arrays\n//const doubleFlatten = arrayOfArrays => arrayOfArrays.map().join(\" \");\n\n/**\n *  So all of the \"special\" props are held here with how they work.\n */\n\nconst operators = {\n    //simple negation\n    $not: (context, values) => mapOperator(context, OP_NOT, values),\n\n    //simple boolean or\n    $or: (context, values) => mapOperator(context, OP_CAN, values),\n\n    //simple boolean and\n    $must: (context, values) => mapOperator(context, OP_MUST, values),\n    $and: (context, values) => mapOperator(context, OP_MUST, values),\n\n    /**\n     *  lucene field missing\n     *  { $missing: \"field\" }, or { $missing: [ \"field\", \"second\" ] }\n     */\n    $missing: (context, values) => values.map(field => luceneMissing(context, field)).join(\" \"),\n\n    /**\n     *  lucene range operator\n     *  { $range: { \"prop\": [ from, to ] }\n     */\n    $range: (context, values) => {\n        return values.reduce((acc, object) => acc.concat(Object.keys(object).map(field => {\n            const [lower, higher] = object[field];\n            return luceneRange(context, field, lower, higher);\n        })), []).join(\" \");\n    },\n    /**\n     *  Search.\n     *  { $search: { field = \"_content.ngram\", term = \"\" }, or { $search: \"term\" } (searches _content.ngram)\n     */\n    $search: (context, values) => {\n        return values.reduce((acc, searchInput) => {\n            let search = searchInput;\n            if (typeof search === \"string\") {\n                //default search type.\n                search = { type: \"ngram\", term: search };\n            }\n            if (!search.field) {\n                search.field = \"_content\";\n            }\n            if (search.type === \"prefix\") {\n                //this is terrible for multi-word searches.\n                return acc.concat(lucenePrefixMatch(context, search.field, search.term));\n            }\n\n            //we always return an array\n            return acc.concat(luceneSearch(context, search.field, search.term, { ngram: search.type === \"ngram\" }));\n        }, []).join(\" \");\n    }\n};\n\n//maps the values with the given operator as a sub segment\nconst mapOperator = (context, op, values) => {\n    //console.log(\"mapOperator\", context, op, values);\n    const currentOp = context.op;\n    //we need to change the the op to MUST if they requested CAN but there is only one option.\n    //So we need to recurse and count\n    const nextOp = (values.length === 1 && values[0].values.length === 1 && op === OP_CAN) ? OP_MUST : op;\n    //set the inner context's op\n    context.op = nextOp;\n    const segment = `${currentOp}(${createQuerySegment(context, values)})`;\n    //return the context's op to the previous\n    context.op = currentOp;\n    return segment;\n};\n\n/**\n *  lucene query pieces\n */\n\n//Quotes a string with double-quotes, escaping existing doubles.\n// we need to make sure this handles:\n// help\" -> \"help\\\"\"\n// help \\\" -> \"help \\\\\\\"\"\n// help \\ -> \"help \\\\\"\nconst quote = function(string) {\n    return `\"${slashString(string)}\"`;\n};\n\nconst SOLIDUS = \"/\";\nconst SLASH = \"\\\\\"; // two because it has to be escaped.\nconst QUOTE = `\"`; // just to make the code more readable\n\nconst slashForward = input => input.replace(/[\\/]/g, SLASH + SOLIDUS);\n\n// this escapes quotes and slashes\nconst slashString = function(input) {\n    return input.replace(/([\\\\\"])/g, function(i, slashOrQuote) {\n        switch (slashOrQuote) {\n            case SLASH: return SLASH + SLASH;\n            case QUOTE: return SLASH + QUOTE;\n            default: break;\n        }\n    });\n};\n\n//run through the term string and pull out terms.\n//if there are any quotes, this becomes complex...\n//so we use iteration and state rather than regexes\n//This function removes the quotes around the terms as well.\n/*\n    examples:\n\n    'test terms' => [\"test\", \"terms\"]\n    'test \"two words\"' => [\"test\", \"two words\"]\n    '\"test unclosed' => [\"\\\"test unclosed\"]\n    '\"test one\" two \"test three\"' => [\"test one\", \"two\", \"test three\"]\n    'something\"with a quote' => [\"something\\\"with\", \"a\", \"quote\"]\n    '\"with \\\"embedded\\\" quotes\"' => [\"with \\\"embedded\\\" quotes\"]\n*/\nconst findQuotedTerms = function(str) {\n    const input = str.trim(); //ensure no trailing space.\n    const terms = [];\n    const l = input.length;\n    let i = 0;\n    let inQuoted = \"\";\n    let inTerm = false;\n    let term = \"\";\n    let char;\n\n    for (; i < l; i++) {\n        char = input[i];\n        if (inTerm) {\n            if ((!inQuoted && char === \" \") || (inQuoted && char === inQuoted)) {\n                terms.push(term);\n                term = \"\";\n                inTerm = false;\n            } else if (inQuoted && char === SLASH && input[i + 1] === inQuoted) {\n                //escaped quote\n                term += SLASH + inQuoted;\n                i++; //bump forwards\n            } else {\n                term += char;\n            }\n        } else if (char !== \" \") {\n            //ignore spaces between terms.\n            if (char === QUOTE || char === \"'\") {\n                inQuoted = char;\n            } else {\n                inQuoted = \"\";\n                term = char;\n            }\n            inTerm = true;\n        }\n    }\n    //flush remaining term\n    terms.push(term);\n    //remove empties from output;\n    return terms.filter(Boolean);\n};\n\n//create a term query with an operator and many possible values.\nfunction luceneTerm(context, field, values) {\n    //console.log(\"term\", context, field, values);\n    const prop = context.entity.prop(field);\n    return values\n        .map(v => prop.encode(v)) // encode for graphit with our mapping\n        .map(v => typeof v === \"string\" ? quote(v) : v) //quote if needed\n        .map(term => term === null\n            ? luceneMissing(context, field) //if term is null, that means the field should be missing.\n            : `${context.op}${slashForward(prop.src)}:${term}`) //create querystring\n        .join(\" \"); //join terms\n}\n\n//create a range query term\nfunction luceneRange(context, field, lower, higher) {\n    const prop = context.entity.prop(field);\n    const [low, high] = [lower, higher]\n        .map(v => prop.encode(v))\n        .map(v => typeof v === \"string\" ? quote(v) : v);\n    return `${context.op}${slashForward(prop.src)}:[${low} TO ${high}]`;\n}\n\n//create a _missing_ query\nfunction luceneMissing(context, field) {\n    const prop = context.entity.prop(field);\n    return `${context.op}_missing_:${quote(prop.src)}`;\n}\n\n//create a search query, this is a little different to a regular term\n//because we assume a phrase and we use placeholders for values.\nfunction luceneSearch(context, field, term, { ngram = false } = {}) {\n    const prop = context.entity.prop(field);\n    let terms;\n    if (term.indexOf(\"\\\"\") > -1 || term.indexOf(\"'\") > -1) {\n        //much more complex, but keeps spaces in quotes, and quoted quotes.\n        terms = findQuotedTerms(term);\n    } else {\n        //simple split\n        terms = term.split(/\\s+/);\n    }\n    const finalTerm = terms.filter(Boolean).join(\" \");\n    //now make a placeholder for the term\n    const placeholder = createPlaceholder(context.placeholders, slashString(finalTerm));\n\n    return `${context.op}${slashForward(prop.src)}${ngram ? \".ngram\" : \"\"}:${placeholder}`;\n}\n\n//lucene is not good at prefixes when spaces are encountered.\n//the least bad solution is to use \"?\" for the spaces.\n//first escape the string (but don't add quotes)\n//then replace space with question mark, then add the final asterisk\nfunction lucenePrefixMatch(context, field, term) {\n    const prop = context.entity.prop(field);\n    const finalTerm = slashString(term).replace(/ /g, \"?\") + \"*\";\n    const placeholder = createPlaceholder(context.placeholders, finalTerm);\n    return `${context.op}${slashForward(prop.src)}:${placeholder}`;\n}\n"
  },
  {
    "__docId__": 167,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "OP_NOT",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~OP_NOT",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": " Schema aware Lucene Wrapper",
    "lineNumber": 4,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 168,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "OP_MUST",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~OP_MUST",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 169,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "OP_CAN",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~OP_CAN",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 170,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "parseLucene",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~parseLucene",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": "parseLucene",
    "description": " The lucene class takes a Schema and creates a query parser.\n\n This is super powerful, the guide to all the syntax options is in the documentation\n for the {@link LuceneQuery} type.",
    "lineNumber": 19,
    "params": [
      {
        "nullable": true,
        "types": [
          "LuceneQuery"
        ],
        "spread": false,
        "optional": false,
        "name": "query",
        "description": "the query to parse"
      },
      {
        "nullable": true,
        "types": [
          "Entity"
        ],
        "spread": false,
        "optional": false,
        "name": "entity",
        "description": "an optional schema entity to use to translate the keys and values"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{ querystring: string, placeholders: object }"
      ],
      "spread": false,
      "description": "the return value contains the string to be used\n         as the query body and the placeholders to go with it (if any)"
    },
    "generator": false
  },
  {
    "__docId__": 171,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createPlaceholder",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~createPlaceholder",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": "Create a placeholder key",
    "lineNumber": 26,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 172,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "placeholderAliasInQuery",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~placeholderAliasInQuery",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 173,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "placeholderKeyInRequest",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~placeholderKeyInRequest",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 174,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "initialContext",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~initialContext",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": " The initial context object for the query building",
    "lineNumber": 37,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 175,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createLuceneQuery",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~createLuceneQuery",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": "using the entity given, map the query object to a Lucene query string + placeholders.",
    "lineNumber": 49,
    "params": [
      {
        "name": "entity",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 176,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "ensureArray",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~ensureArray",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 177,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "noRecurseKeys",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~noRecurseKeys",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 178,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "normaliseQuery",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~normaliseQuery",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 77,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createQuerySegment",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~createQuerySegment",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": " This is the recursive part that constructs the querystring from the\n query given.",
    "lineNumber": 94,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "query",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 180,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "operators",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~operators",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": " So all of the \"special\" props are held here with how they work.",
    "lineNumber": 114,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 181,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapOperator",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~mapOperator",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 167,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 182,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "quote",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~quote",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": " lucene query pieces",
    "lineNumber": 190,
    "params": [
      {
        "name": "string",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 183,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "SOLIDUS",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~SOLIDUS",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "SLASH",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~SLASH",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 195,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 185,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "QUOTE",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~QUOTE",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 186,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "slashForward",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~slashForward",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 187,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "slashString",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~slashString",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "params": [
      {
        "name": "input",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 188,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "findQuotedTerms",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~findQuotedTerms",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 189,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "luceneTerm",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~luceneTerm",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 267,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "values",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 190,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "luceneRange",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~luceneRange",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 280,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "lower",
        "types": [
          "*"
        ]
      },
      {
        "name": "higher",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 191,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "luceneMissing",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~luceneMissing",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 289,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 192,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "luceneSearch",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~luceneSearch",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 296,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "term",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern3",
        "optional": true,
        "types": [
          "{\"ngram\": *}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 193,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "lucenePrefixMatch",
    "memberof": "src/lucene/index.js",
    "longname": "src/lucene/index.js~lucenePrefixMatch",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/lucene",
    "importStyle": null,
    "description": null,
    "lineNumber": 317,
    "undocument": true,
    "params": [
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "field",
        "types": [
          "*"
        ]
      },
      {
        "name": "term",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "string"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 194,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/schema/entity.js",
    "memberof": null,
    "longname": "src/schema/entity.js",
    "access": null,
    "description": null,
    "lineNumber": 6,
    "content": "/**\n *  The entity is an object which provides the information to\n *  convert database database results into application data and\n *  application queries into database format\n */\nimport codec from \"../codec\";\n\nconst stringCodec = codec(\"string\");\nconst listCodec = codec(\"list\");\nconst identity = codec(\"identity\");\nconst iso8601 = codec(\"iso8601\");\n// map an array of objects to an object keyed on the given key\nconst indexBy = key => (acc, obj) => (acc[obj[key]] = obj, acc);\n\n/**\n *  @ignore - internal only\n */\nexport const $dangerouslyGetProps = Symbol(\"dangerouslyGetProps\");\n/**\n *  @ignore - internal only\n */\nexport const $dangerouslyGetRelations = Symbol(\"dangerouslyGetRelations\");\n/**\n *  @ignore - internal only\n */\nexport const $dangerouslyGetDefinition = Symbol(\"dangerouslyGetDefinition\");\n/**\n *  @ignore - internal only\n */\nexport const $internal = Symbol(\"internal entity\");\n\n/**\n *  The entity is an object which provides the information to\n *  convert database database results into application data and\n *  application queries into database format.\n *\n *  @see manual/overview.html#schema\n *  @param {object} definition - the schema definition of this entity (see the manual)\n *  @param {Schema} schema - the actual schema this entity is defined in.\n *  @return {Entity}\n */\nexport default function createEntity(definition, schema) {\n    const firstLetter = definition.name ? definition.name[0] : \"x\";\n    if (!definition[$internal] && firstLetter !== firstLetter.toUpperCase()) {\n        throw new Error(`entity defition name must start with a Capital letter (${definition.name})`);\n    }\n    const props = createPropList(schema, definition.required, definition.optional, definition.virtual);\n    const byDb = props.reduce(indexBy(\"src\"), {});\n    const byApp = props.reduce(indexBy(\"dst\"), {});\n\n    const shouldMapFreeAttributes = definition.includeUnmappedFreeAttributes === true;\n\n    const getProp = name => {\n        if (byApp[name]) {\n            return byApp[name];\n        }\n        if (byDb[name]) {\n            return byDb[name];\n        }\n        //nothing\n        return;\n    };\n\n    const relations = createRelationMap(definition.relations);\n    const getRelation = name => {\n        if (relations[name]) {\n            return relations[name];\n        }\n        //nothing\n        return;\n    };\n\n    const convert = (encode = true) => input => {\n        return objectEntries(input)\n            .reduce((output, [key, value]) => {\n                const prop = encode ? byApp[key] : byDb[key];\n                if (!prop) {\n                    //this might be missing, or it may be free.\n                    //if we are decoding, we have access to unmapped free props.\n                    if (!encode && isFreeAttribute(key) && shouldMapFreeAttributes) {\n                        //this is a little different\n                        addFreeAttribute(output, key, value);\n                    }\n                    return output;\n                } else if ((encode && prop.immutable)) {\n                    //skip readOnly fields on encode\n                    return output;\n                }\n                if (encode) {\n                    //remember null is used for unset, so pass-through\n                    output[prop.src] = value === null ? null : prop.encode(value);\n                } else {\n                    output[prop.dst] = prop.decode(value);\n                }\n                return output;\n            }, {});\n    };\n\n    const entity = Object.create(null, {\n        ogit: {\n            enumerable: true,\n            value: definition.ogit\n        },\n        name: {\n            enumerable: true,\n            value: definition.name\n        },\n        relation: {\n            enumerable: true,\n            value: getRelation\n        },\n        prop: {\n            enumerable: true,\n            value: getProp\n        },\n        decode: {\n            enumerable: true,\n            value: convert(false)\n        },\n        encode: {\n            enumerable: true,\n            value: convert(true)\n        },\n        internal: {\n            enumerable: true,\n            value: definition[$internal] === true\n        }\n    });\n    entity[$dangerouslyGetProps] = () => props;\n    entity[$dangerouslyGetRelations] = () => relations;\n    entity[$dangerouslyGetDefinition] = () => definition;\n    return entity;\n}\n\nconst internalProps = [\n    {\n        src: \"ogit/_id\",\n        dst: \"_id\",\n        encode: stringCodec.decode,\n        decode: stringCodec.encode,\n        required: false\n    },\n    { //_content and fields will be moved to ontology definition, e.g. github.com/arago/OGIT\n        src: \"ogit/_content\",\n        dst: \"_content\",\n        encode: stringCodec.decode,\n        decode: stringCodec.encode,\n        required: false\n    },\n    {\n        src: \"ogit/_tags\",\n        dst: \"_tags\",\n        encode: listCodec.decode,\n        decode: listCodec.encode,\n        required: false\n    }\n];\n\nconst readOnlyProps = [\n    \"ogit/_created-on\",\n    \"ogit/_modified-on\",\n    \"ogit/_created-by\",\n    \"ogit/_modified-by\"\n].map(src => ({\n    src,\n    dst: src.split(\"/\")[1],\n    decode: identity.decode,\n    encode: /-on$/.test(src) ? iso8601.encode : identity.encode,\n    required: false,\n    immutable: true\n}));\n\nconst _typeProp = {\n    src: \"ogit/_type\",\n    dst: \"_type\",\n    required: false\n};\nconst typeProp = schema => {\n    if (\"encode\" in _typeProp) {\n        return _typeProp;\n    }\n    return Object.assign(_typeProp, {\n        encode: name => schema.get(name).ogit,\n        decode: ogit => schema.get(ogit).name\n    });\n};\n\n//free attributes start with Slash.\nconst isFreeAttribute = prop => prop.indexOf(\"/\") === 0;\n//adding one goes into the free pot.\nconst addFreeAttribute = (output, key, value) => {\n    if (\"_free\" in output === false) {\n        output._free = {};\n    }\n    output._free[key.substring(1)] = value; //no coercion.\n};\n\nconst ensureFullProps = base => ([key, def]) => {\n    const result = {\n        dst: key\n    };\n    if (typeof def === \"string\") {\n        Object.assign(result, { src: def }, codec(\"string\"), base);\n    } else {\n        Object.assign(result, { src: def.src }, codec(def.type || \"string\"), base);\n    }\n    return result;\n};\n\n//to iterate objects easily\nconst objectEntries = obj => Object.keys(obj).map(key => [key, obj[key]]);\n\n//create a flat array of props.\nconst createPropList = (schema, required = {}, optional = {}, virtual = {}) => {\n    //we add the defaults as well.\n    return internalProps\n        .concat([typeProp(schema)])\n        .concat(readOnlyProps)\n        .concat(objectEntries(required).map(ensureFullProps({ required: true })))\n        .concat(objectEntries(optional).map(ensureFullProps({ required: false })))\n        .concat(objectEntries(virtual).map(ensureFullProps({ writable: false })));\n};\n\n//parse the relations into a common format.\nconst createRelationMap = (relations = {}) => {\n    return objectEntries(relations).reduce((map, [alias, def]) => {\n        const relation = [];\n        if (typeof def === \"string\" || !Array.isArray(def)) {\n            relation.push(def);\n        } else {\n            relation.push(...def);\n        }\n        map[alias] = {\n            alias,\n            hops: relation.reduce(createRelation, [])\n        };\n        return map;\n    }, {});\n};\n\n/**\n *  Create the long form relation object from a string or object\n *\n *  The object should look like this:\n *  {\n *      direction: \"in\" | \"out\",\n *      verb: \"ogit/edgeType\",\n *      vertices: [ \"ogit/vertexType\" ],\n *      filter: { \"ogit/attribute\": \"ogit/value\" }\n *  }\n *\n *  The string shorthand is\n *\n *  \"ogit/edgeType -> ogit/vertexType|ogit/otherType, ...\"\n *\n */\nconst createRelation = (hops, def) => {\n    //if string, we must parse.\n    if (typeof def === \"string\") {\n        return parseRelationString(def).reduce(createRelation, hops);\n    }\n    const {\n        direction,\n        verb,\n        filter = null,\n        vertex = false,\n        vertices = []\n    } = def;\n    const vertexTypes = [];\n    //now check the minimal definition.\n    if (direction !== \"in\" && direction !== \"out\") {\n        throw new Error(`relation: direction must be \"in\" or \"out\" not: ${direction}`);\n    }\n    if (typeof verb !== \"string\" || verb.indexOf(\"ogit/\") !== 0) {\n        throw new Error(`relation: verb must be 'ogit/...' got: ${verb}`);\n    }\n    //this should be a single item, but it might get an array...\n    if (vertex) {\n        if (Array.isArray(vertex)) {\n            vertexTypes.push(...vertex);\n        } else {\n            vertexTypes.push(vertex);\n        }\n    }\n    //this is the one that should be used as an array, be we might get a single item.\n    if (!Array.isArray(vertices)) {\n        vertexTypes.push(vertices);\n    } else {\n        vertexTypes.push(...vertices);\n    }\n    // now check everything we got was a string.\n    if (vertexTypes.some(r => typeof r !== \"string\") || vertexTypes.length === 0) {\n        throw new Error(`relation: vertex must be a string, or an array of strings`);\n    }\n    //OK we have all the info we need, should we generate the gremlin base alias query now? nah.\n    return hops.concat([{\n        direction,\n        filter,\n        verb,\n        vertices: vertexTypes\n    }]);\n};\n\n//parse the string form of the relation definition.\n//\n// the definition is in the form \"verb dir type|type, verb dir type|type, ...\"\nconst parseRelationString = string => {\n    //split the parts into an array on comma.\n    return string.split(/\\s*,\\s*/)\n        .map(rel => {\n            //OK this is a single one.\n            const [verb, dir, types, ...rest] = rel.split(/\\s+/);\n            //if there is \"rest\" then the definiton is probably done something wrong.\n            if (rest.length) {\n                throw new Error(`relation: error parsing '${rel}' - (if you need a filter, use the longhand object form)`);\n            }\n            let direction;\n            switch (dir) {\n                case \"<-\":\n                    direction = \"in\";\n                    break;\n                case \"->\":\n                    direction = \"out\";\n                    break;\n                default:\n                    direction = dir;\n            }\n            return {\n                direction,\n                verb,\n                vertices: types.split(\"|\").map(v => v.trim())\n            };\n        });\n};\n"
  },
  {
    "__docId__": 195,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "stringCodec",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~stringCodec",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 196,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "listCodec",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~listCodec",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 197,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "identity",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~identity",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 198,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "iso8601",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~iso8601",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 199,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "indexBy",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~indexBy",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 200,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "$dangerouslyGetProps",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~$dangerouslyGetProps",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": "{$dangerouslyGetProps}",
    "description": "",
    "lineNumber": 18,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 201,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "$dangerouslyGetRelations",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~$dangerouslyGetRelations",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": "{$dangerouslyGetRelations}",
    "description": "",
    "lineNumber": 22,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 202,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "$dangerouslyGetDefinition",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~$dangerouslyGetDefinition",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": "{$dangerouslyGetDefinition}",
    "description": "",
    "lineNumber": 26,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 203,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "$internal",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~$internal",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": "{$internal}",
    "description": "",
    "lineNumber": 30,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 204,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createEntity",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~createEntity",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": "createEntity",
    "description": " The entity is an object which provides the information to\n convert database database results into application data and\n application queries into database format.",
    "see": [
      "manual/overview.html#schema"
    ],
    "lineNumber": 42,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "definition",
        "description": "the schema definition of this entity (see the manual)"
      },
      {
        "nullable": null,
        "types": [
          "Schema"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "the actual schema this entity is defined in."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Entity"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 205,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "internalProps",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~internalProps",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 206,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "readOnlyProps",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~readOnlyProps",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 159,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 207,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "_typeProp",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~_typeProp",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 173,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 208,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "typeProp",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~typeProp",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 209,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "isFreeAttribute",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~isFreeAttribute",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 189,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 210,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "addFreeAttribute",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~addFreeAttribute",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 211,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "ensureFullProps",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~ensureFullProps",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 198,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 212,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "objectEntries",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~objectEntries",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 211,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 213,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createPropList",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~createPropList",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 214,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 214,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createRelationMap",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~createRelationMap",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 215,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "createRelation",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~createRelation",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": " Create the long form relation object from a string or object\n\n The object should look like this:\n {\n     direction: \"in\" | \"out\",\n     verb: \"ogit/edgeType\",\n     vertices: [ \"ogit/vertexType\" ],\n     filter: { \"ogit/attribute\": \"ogit/value\" }\n }\n\n The string shorthand is\n\n \"ogit/edgeType -> ogit/vertexType|ogit/otherType, ...\"",
    "lineNumber": 257,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 216,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "parseRelationString",
    "memberof": "src/schema/entity.js",
    "longname": "src/schema/entity.js~parseRelationString",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/entity",
    "importStyle": null,
    "description": null,
    "lineNumber": 307,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 217,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/schema/index.js",
    "memberof": null,
    "longname": "src/schema/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import createEntity, { $internal } from \"./entity\";\nimport { mapIfArray } from \"../utils\";\n\n/**\n *  Defines an Ontology to application mapping\n */\nexport default class Schema {\n    /**\n     *  @param {Array<object>} initialDefinitions - definitions to apply on create\n     */\n    constructor(initialDefinitions = false) {\n        /**\n         *  the entity lookup table\n         *\n         *  @private\n         *  @type {object<string, Entity>}\n         */\n        this.entities = {};\n        /**\n         *  the list of all entity names\n         *\n         *  @private\n         *  @type {Array<string>}\n         */\n        this.names = [];\n\n        /**\n         *  The internal only type entity\n         *\n         *  @private\n         *  @type {Entity}\n         */\n        this.internal = createEntity({\n            [$internal]: true\n        }, this);\n\n        //allows define to work seamlessly with single and arrays of definitions\n        this.define = mapIfArray(this.define.bind(this));\n\n        if (initialDefinitions) {\n            this.define(initialDefinitions);\n        }\n    }\n\n    /**\n     *  Define a new entity type in the Schema\n     *\n     *  @param {object} entityMapping - the definition\n     *  @return {undefined}\n     */\n    define(entityMapping) {\n        const entity = createEntity(entityMapping, this);\n        if (entity.name in this.entities) {\n            throw new Error(`duplicate entity name: ${entity.name}`);\n        }\n        if (entity.ogit in this.entities) {\n            throw new Error(`duplicate entity for vertex type: ${entity.ogit}`);\n        }\n        this.entities[entity.name] = entity;\n        this.entities[entity.ogit] = entity;\n        this.names.push(entity.name);\n    }\n\n    /**\n     *  Retrieve an entity by app name or OGIT name\n     *\n     *  A special case when no argument is given returns the *internal*\n     *  entity, which can translate OGIT internal props only.\n     *\n     *  @param {?string} entityType - the name or OGIT name of the entity\n     *  @return {?Entity} - may be null if the type given does not exist\n     */\n    get(entityType = false) {\n        //special case for no type given\n        if (!entityType) {\n            return this.internal;\n        }\n        return this.entities[entityType];\n    }\n}\n\n"
  },
  {
    "__docId__": 218,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Schema",
    "memberof": "src/schema/index.js",
    "longname": "src/schema/index.js~Schema",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema",
    "importStyle": "Schema",
    "description": " Defines an Ontology to application mapping",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 219,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#constructor",
    "access": null,
    "description": "",
    "lineNumber": 11,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<object>"
        ],
        "spread": false,
        "optional": false,
        "name": "initialDefinitions",
        "description": "definitions to apply on create"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 220,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "entities",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#entities",
    "access": "private",
    "description": " the entity lookup table",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "object<string, Entity>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 221,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "names",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#names",
    "access": "private",
    "description": " the list of all entity names",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 222,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "internal",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#internal",
    "access": "private",
    "description": " The internal only type entity",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "Entity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 223,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "define",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#define",
    "access": null,
    "description": null,
    "lineNumber": 38,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 224,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "define",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#define",
    "access": null,
    "description": " Define a new entity type in the Schema",
    "lineNumber": 51,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "entityMapping",
        "description": "the definition"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "undefined"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 225,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "get",
    "memberof": "src/schema/index.js~Schema",
    "longname": "src/schema/index.js~Schema#get",
    "access": null,
    "description": " Retrieve an entity by app name or OGIT name\n\n A special case when no argument is given returns the *internal*\n entity, which can translate OGIT internal props only.",
    "lineNumber": 73,
    "params": [
      {
        "nullable": true,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "entityType",
        "description": "the name or OGIT name of the entity"
      }
    ],
    "return": {
      "nullable": true,
      "types": [
        "Entity"
      ],
      "spread": false,
      "description": "may be null if the type given does not exist"
    },
    "generator": false
  },
  {
    "__docId__": 226,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/schema/validate.js",
    "memberof": null,
    "longname": "src/schema/validate.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import { statSync, readFileSync, readdirSync } from \"fs\";\nimport { join } from \"path\";\nimport { safeLoad } from \"js-yaml\";\n\nimport { $dangerouslyGetProps, $dangerouslyGetRelations } from \"./entity\";\n\n/**\n *  Validate a schema against an OGIT ontology\n *\n *  This allows a schema to validate itself against a given YAML OGIT\n *  ontology definition, either as a single file or multiple (e.g. a cloned repo)\n *\n *  This is important as it allows our schema definitions to remain correct with\n *  respect to the ontology that your GraphIT uses.\n *\n *  This is a `node` only piece of functionality and is intended to run as part of a linting\n *  or testing phase.\n *\n *  @param {Schema} schema - the schema to check\n *  @param {string} ontologyLocation - a path to an ontology file or repo.\n *  @return {object} result\n *  @property {number} errors - the number of problems found\n *  @property {object.<string,Array<string>>} detail - the errors grouped by entity name\n */\nexport default function validate(schema, ontologyLocation) {\n    let ontology;\n    try {\n        ontology = load(ontologyLocation);\n    } catch (e) {\n        return {\n            errors: 1,\n            loadOntologyFail: e.message\n        };\n    }\n    //schema.names has the application name of each entity.\n    return schema.names\n        .map(name => schema.get(name))\n        .reduce((output, entity) => {\n            const errors = validateEntity(entity, ontology);\n            if (errors.length) {\n                output.errors += errors.length;\n                output.detail[entity.name] = errors;\n            }\n            return output;\n        }, { errors: 0, detail: {} });\n}\n\n//load an ontology.\n//location should be a path\n//if a file, load just that.\n//if a dir, recurse and load all files.\nconst load = (location, ontology = emptyOntology()) => {\n    const stat = statSync(location);\n    if (stat.isDirectory()) {\n        readdirSync(location).forEach(entry => {\n            const fullPath = join(location, entry);\n            load(fullPath, ontology);\n        });\n    } else if (stat.isFile() && isYamlFile(location)) {\n        const data = safeLoad(readFileSync(location, \"utf8\"), { onWarning: () => {} });\n        //data should be an array\n        if (Array.isArray(data)) {\n            data.forEach(object => {\n                let type, item;\n                switch (true) {\n                    case (\"Entity\" in object):\n                        type = \"entities\";\n                        item = object.Entity;\n                        break;\n                    // we don't actually care about this...\n                    // case (\"Attribute\" in object):\n                    //     type = \"attributes\";\n                    //     item = object.Attribute;\n                    //     break;\n                    case (\"Verb\" in object):\n                        type = \"verbs\";\n                        item = object.Verb;\n                        break;\n                    default:\n                        //no default\n                        return;\n                }\n                item.__sourcefile__ = location;\n                item.ogit = depurl(item.id);\n                ontology[type][item.ogit] = item;\n            });\n        }\n    }\n    return ontology;\n};\n\nconst depurl = name => name.replace(\"http://www.purl.org/\", \"\");\n\nconst isYamlFile = file => /\\.ya?ml$/.test(file);\n\nconst emptyOntology = () => ({\n    entities: {},\n    //attributes: {},\n    verbs: {}\n});\n\n// now the tricky one, validate an entity against an ontology.\n//\n// The rules are:\n//\n//  - the entity.ogit name MUST exist in the ontology\n//  - any *mandatory* fields in ontology MUST be *required* here.\n//  - any required/optional fields using *non-free* attributes MUST reference valid attributes in ontology\n//  - any relations must be valid:\n//    - all hops have valid verbs for the entities and directions\n//    - any filters must be on valid properties\nfunction validateEntity(appEntity, { entities, verbs }) {\n    if (appEntity.ogit in entities === false) {\n        return [`Entity (${appEntity.name}) does not exist in Ontology as '${appEntity.ogit}'`];\n    }\n    const ogitEntity = entities[appEntity.ogit];\n    const errors = [];\n\n    //check mandatory attributes\n    if (ogitEntity.attributes.mandatory) {\n        ogitEntity.attributes.mandatory.map(depurl).forEach(attr => {\n            //invalid if not in appEntity.required.\n            const prop = appEntity.prop(attr);\n            if (!prop) {\n                errors.push(`Ontology mandatory field (${attr}) not defined in Entity (${appEntity.name})`);\n            } else if (!prop.required) {\n                errors.push(`Ontology mandatory field (${attr}) not listed as 'required' in Entity (${appEntity.name})`);\n            }\n        }, []);\n    }\n\n    //check non-free attributes valid\n    //first get the list of attributes in this ontology item\n    const validAttributes = getValidAttributes(ogitEntity);\n\n    appEntity[$dangerouslyGetProps]()\n        //we are checking non-free attributes. so we remove the free ones\n        //and also remove the \"ogit\" internal attributes\n        .filter(prop => prop.src.charAt(0) !== \"/\" && !/^ogit\\/_/.test(prop.src))\n        .filter(prop => !validAttributes[prop.src]) //remove valid ones.\n        .forEach(invalidProp => {\n            //all the remaining are invalid\n            errors.push(`Entity ${invalidProp.required ? \"required\" : \"optional\"} property (${invalidProp.dst}) does not reference an available attribute in Ontology (${invalidProp.src})`);\n        });\n\n    //now check relations.\n    const relations = appEntity[$dangerouslyGetRelations]();\n\n    Object.keys(relations).forEach(alias => {\n        let startNodes = [appEntity.ogit];\n        let broken = false;\n        relations[alias].hops.forEach((hop, i) => {\n            if (broken) {\n                return;\n            }\n            const { direction, verb, filter, vertices } = hop;\n            //first check the verb exists.\n            if (verb in verbs === false) {\n                errors.push(`Relation (${alias}) invalid at hop (${i + 1}): Verb (${verb}) does not exist in ontology.`);\n                broken = false;\n                return;\n            }\n            const connections = getValidConnections(verbs[verb]);\n            vertices.forEach(endNode => {\n                startNodes.forEach(startNode => {\n                    const key = direction === \"out\" ? [startNode, endNode] : [endNode, startNode];\n                    if (\n                        !connections[key.join()]) {\n                        errors.push(`Relation (${alias}) invalid at hop (${i + 1}): Connection from '${key[0]} --> ${verb} -> ${key[1]}' not allowed.`);\n                    }\n                });\n                // also check the endNodes for filter props if filter exists and has\n                // non-free attributes in it.\n                if (filter) {\n                    const endDefinition = entities[endNode];\n                    const validEndAttributes = getValidAttributes(endDefinition);\n                    Object.keys(filter)\n                        //remove any free or internal props.\n                        .filter(prop => prop.src.charAt(0) !== \"/\" || !/^ogit\\/_/.test(prop.src))\n                        //remove valid props.\n                        .filter(prop => !validEndAttributes[prop])\n                        //the rest are errors\n                        .forEach(prop => errors.push(`Relation (${alias}) invalid at hop (${i + 1}): filter contains invalid prop (${prop}) for Entity (${endNode})`));\n                }\n            });\n            //now switch the start nodes and let it repeat.\n            startNodes = vertices;\n        });\n    });\n    return errors;\n}\n\nconst validAttributeCache = {};\nfunction getValidAttributes(entity) {\n    if (entity.ogit in validAttributeCache === false) {\n        validAttributeCache[entity.ogit] = (entity.attributes.mandatory || [])\n            .concat(entity.attributes.optional || [])\n            .map(depurl)\n            .reduce((valid, attr) => (valid[attr] = true, valid), {});\n    }\n    return validAttributeCache[entity.ogit];\n}\n\nconst validConnectionsCache = {};\nfunction getValidConnections(verb) {\n    if (verb.ogit in validConnectionsCache === false) {\n        validConnectionsCache[verb.ogit] = (verb.allowed || [])\n            .map(({ from, to }) => [depurl(from), depurl(to)].join())\n            .reduce((valid, attr) => (valid[attr] = true, valid), {});\n    }\n    return validConnectionsCache[verb.ogit];\n}\n"
  },
  {
    "__docId__": 227,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "validate",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~validate",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": "validate",
    "description": " Validate a schema against an OGIT ontology\n\n This allows a schema to validate itself against a given YAML OGIT\n ontology definition, either as a single file or multiple (e.g. a cloned repo)\n\n This is important as it allows our schema definitions to remain correct with\n respect to the ontology that your GraphIT uses.\n\n This is a `node` only piece of functionality and is intended to run as part of a linting\n or testing phase.",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "Schema"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": "the schema to check"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "ontologyLocation",
        "description": "a path to an ontology file or repo."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "errors",
        "description": "the number of problems found"
      },
      {
        "nullable": null,
        "types": [
          "object.<string,Array<string>>"
        ],
        "spread": false,
        "optional": false,
        "name": "detail",
        "description": "the errors grouped by entity name"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "result"
    },
    "generator": false
  },
  {
    "__docId__": 228,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "load",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~load",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 52,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "depurl",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~depurl",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 92,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "isYamlFile",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~isYamlFile",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 231,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "emptyOntology",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~emptyOntology",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "validateEntity",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~validateEntity",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 112,
    "undocument": true,
    "params": [
      {
        "name": "appEntity",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectPattern1",
        "types": [
          "{\"entities\": *, \"verbs\": *}"
        ],
        "defaultRaw": {
          "entities": null,
          "verbs": null
        },
        "defaultValue": "{\"entities\":null,\"verbs\":null}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 233,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "validAttributeCache",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~validAttributeCache",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 193,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 234,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "getValidAttributes",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~getValidAttributes",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 194,
    "undocument": true,
    "params": [
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 235,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "validConnectionsCache",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~validConnectionsCache",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 236,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "getValidConnections",
    "memberof": "src/schema/validate.js",
    "longname": "src/schema/validate.js~getValidConnections",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/schema/validate",
    "importStyle": null,
    "description": null,
    "lineNumber": 205,
    "undocument": true,
    "params": [
      {
        "name": "verb",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 237,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/types/externals.js",
    "memberof": null,
    "longname": "src/types/externals.js",
    "access": null,
    "description": null,
    "lineNumber": 4,
    "content": "/**\n * @external {Connection} https://github.com/arago/js-graphit-client/blob/master/src/connection.js\n */\n"
  },
  {
    "__docId__": 238,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Connection",
    "externalLink": "https://github.com/arago/js-graphit-client/blob/master/src/connection.js",
    "memberof": "src/types/externals.js",
    "longname": "src/types/externals.js~Connection",
    "access": null,
    "description": ""
  },
  {
    "__docId__": 239,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/types/typedefs.js",
    "memberof": null,
    "longname": "src/types/typedefs.js",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "content": "/**\n * The codec represents a simple `encode`/`decode` function pair\n *\n * @typedef {Object} Codec\n * @property {function(input: *): string} encode - the `encoder` function\n * @property {function(input: string): *} decode - the `decoder` function\n */\n\n/**\n * Represents a result which is either a single vertex or an array of them\n *\n * @typedef {GraphVertex|Array<GraphVertex>} OneOrMoreVertices\n */\n\n/**\n *  This is our representation of a Lucene Query.\n *\n *  When parsed the keys and value's here automagically get converted by our {@link Schema}\n *  into the correct values for the GraphIT side.\n *\n *  For the full API documentation for this look at [Lucene Queries](manual/usage.html#lucene-query-syntax)\n *\n *  @typedef {object} LuceneQuery\n */\n\n /**\n  *  A possible branch definition for a Gremlin function\n  *\n  *  Used in `transform`, `copySplit`, etc...\n  *\n  *  It is either a static string, or a function which is provided a gremlin pipeline\n  *  which the function should act on.\n  *\n  *  @typedef {string|function(pipe: GremlinQueryBuilder)} GremlinBranch\n  */\n"
  },
  {
    "__docId__": 240,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "Codec",
    "memberof": "src/types/typedefs.js",
    "longname": "src/types/typedefs.js~Codec",
    "access": null,
    "description": "The codec represents a simple `encode`/`decode` function pair",
    "properties": [
      {
        "nullable": null,
        "types": [
          "function(input: *): string"
        ],
        "spread": false,
        "optional": false,
        "name": "encode",
        "description": "the `encoder` function"
      },
      {
        "nullable": null,
        "types": [
          "function(input: string): *"
        ],
        "spread": false,
        "optional": false,
        "name": "decode",
        "description": "the `decoder` function"
      }
    ],
    "type": {
      "types": [
        "Object"
      ],
      "optional": false,
      "name": "Codec"
    }
  },
  {
    "__docId__": 241,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "OneOrMoreVertices",
    "memberof": "src/types/typedefs.js",
    "longname": "src/types/typedefs.js~OneOrMoreVertices",
    "access": null,
    "description": "Represents a result which is either a single vertex or an array of them",
    "type": {
      "types": [
        "GraphVertex",
        "Array<GraphVertex>"
      ],
      "optional": false,
      "name": "OneOrMoreVertices"
    }
  },
  {
    "__docId__": 242,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "LuceneQuery",
    "memberof": "src/types/typedefs.js",
    "longname": "src/types/typedefs.js~LuceneQuery",
    "access": null,
    "description": " This is our representation of a Lucene Query.\n\n When parsed the keys and value's here automagically get converted by our {@link Schema}\n into the correct values for the GraphIT side.\n\n For the full API documentation for this look at [Lucene Queries](manual/usage.html#lucene-query-syntax)",
    "type": {
      "types": [
        "object"
      ],
      "optional": false,
      "name": "LuceneQuery"
    }
  },
  {
    "__docId__": 243,
    "kind": "typedef",
    "static": true,
    "variation": null,
    "name": "GremlinBranch",
    "memberof": "src/types/typedefs.js",
    "longname": "src/types/typedefs.js~GremlinBranch",
    "access": null,
    "description": " A possible branch definition for a Gremlin function\n\n Used in `transform`, `copySplit`, etc...\n\n It is either a static string, or a function which is provided a gremlin pipeline\n which the function should act on.",
    "type": {
      "types": [
        "string",
        "function(pipe: GremlinQueryBuilder)"
      ],
      "optional": false,
      "name": "GremlinBranch"
    }
  },
  {
    "__docId__": 244,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/utils/index.js",
    "memberof": null,
    "longname": "src/utils/index.js",
    "access": null,
    "description": null,
    "lineNumber": 8,
    "content": "/**\n *  simple deep clone\n *\n *  only works on primitives, arrays and plain objects.\n *\n *  @ignore - internal helper\n */\nexport function clone(object) {\n    //is it an array?\n    if (Array.isArray(object)) {\n        return object.map(clone);\n    }\n    //is it an object?\n    if (Object.prototype.toString.call(object) === \"[object Object]\") {\n        return Object.keys(object).reduce((acc, key) => (acc[key] = clone(object[key]), acc), {});\n    }\n    //assume a primitive\n    return object;\n}\n\n/**\n *  Merge 2 objects, clone props from old, that don't exist on new.\n *  If they exist on new and are null, we remove but don't replace\n *\n *  NB. This mutates the data object.\n *\n *  @ignore\n */\nexport function merge(old = {}, data = {}) {\n    Object.keys(old).forEach(key => {\n        if (key in data === false) {\n            data[key] = old[key];\n        }\n    });\n    Object.keys(data).forEach(key => {\n        if (data[key] === null) {\n            delete data[key];\n        }\n    });\n    return data;\n}\n\n/**\n * this is a \"promise\" friendly filter function\n *\n * e.g. .then(filter(x => x > 2)).then...\n * geared up for array-or-not semantics.\n *\n *  @ignore - internal helper\n */\nexport const filter = fn => input => Array.isArray(input) ? input.filter(fn) : [input].filter(fn)[0]; //could be undefined...\n\n/**\n *  decode the database results into Vertex objects.\n *\n *  @ignore - internal helper\n */\nexport const decodeResults = (ctx, entity) => mapIfArray(item => {\n    const decoder = entity.internal ? ctx.getEntity(item[\"ogit/_type\"]) : entity;\n    try {\n        return decoder.decode(item);\n    } catch (e) {\n        console.warn(`error converting entity (as ${decoder.name}):`, item);\n    }\n});\n\n/**\n *  map sync functions if array and singly if not.\n *\n *  @ignore - internal helper\n */\nexport const mapIfArray = fn => input => Array.isArray(input) ? input.map(fn) : fn(input);\n\n/**\n *  allow the function to act on one of more objects.\n *\n *  @ignore - internal helper\n */\nexport const mapPromiseIfArray = fn => input => Array.isArray(input) ? Promise.all(input.map(fn)) : Promise.resolve(fn(input));\n"
  },
  {
    "__docId__": 245,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "clone",
    "memberof": "src/utils/index.js",
    "longname": "src/utils/index.js~clone",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/utils",
    "importStyle": "{clone}",
    "description": " simple deep clone\n\n only works on primitives, arrays and plain objects.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "object",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 246,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "merge",
    "memberof": "src/utils/index.js",
    "longname": "src/utils/index.js~merge",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/utils",
    "importStyle": "{merge}",
    "description": " Merge 2 objects, clone props from old, that don't exist on new.\n If they exist on new and are null, we remove but don't replace\n\n NB. This mutates the data object.",
    "lineNumber": 29,
    "ignore": true,
    "params": [
      {
        "name": "old",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      },
      {
        "name": "data",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 247,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "filter",
    "memberof": "src/utils/index.js",
    "longname": "src/utils/index.js~filter",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/utils",
    "importStyle": "{filter}",
    "description": "this is a \"promise\" friendly filter function\n\ne.g. .then(filter(x => x > 2)).then...\ngeared up for array-or-not semantics.",
    "lineNumber": 51,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 248,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "decodeResults",
    "memberof": "src/utils/index.js",
    "longname": "src/utils/index.js~decodeResults",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/utils",
    "importStyle": "{decodeResults}",
    "description": " decode the database results into Vertex objects.",
    "lineNumber": 58,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 249,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapIfArray",
    "memberof": "src/utils/index.js",
    "longname": "src/utils/index.js~mapIfArray",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/utils",
    "importStyle": "{mapIfArray}",
    "description": " map sync functions if array and singly if not.",
    "lineNumber": 72,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 250,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapPromiseIfArray",
    "memberof": "src/utils/index.js",
    "longname": "src/utils/index.js~mapPromiseIfArray",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/utils",
    "importStyle": "{mapPromiseIfArray}",
    "description": " allow the function to act on one of more objects.",
    "lineNumber": 79,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 251,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/vertex/graph.js",
    "memberof": null,
    "longname": "src/vertex/graph.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import Vertex, { isVertex } from \"./index\";\nexport { isVertex };\n\nimport { merge } from \"../utils\";\n\nconst $guard = Symbol(\"VertexGaurd\");\n/**\n *  Create a Context bound GraphVertex\n *\n *  The GraphVertex constructor should not be used directly, rather through\n *  this function.\n *\n *  It keeps the cache fresh, but clobbers object references\n *  so only a single object for each ID is created and updates\n *  create new versions.\n *\n *  @param {object} data - the initial data (as with {@link Vertex})\n *  @param {Context} context - the context this vertex was retrieved in\n *  @return {GraphVertex} - the vertex\n */\nexport function createVertex(data, context) {\n    const id = data._id;\n    data._fetched = Date.now();\n    const vtx = new GraphVertex(data, context, $guard);\n    mergeRelations(context._cache.get(id), vtx);\n    context._cache.set(id, vtx);\n    return vtx;\n}\n\n/**\n * Used internally\n * @ignore\n */\nexport function mergeRelations(oldVtx, newVtx) {\n    if (oldVtx) {\n        [\"_counts\", \"_ids\", \"_vertices\"].forEach(prop => {\n            newVtx[prop] = merge(oldVtx[prop], newVtx[prop]);\n        });\n    }\n}\n\n//pull only the changed data from the vertex object\nconst getChangedData = vertex => {\n    return Object.keys(vertex._before)\n            .reduce((obj, key) => (obj[key] = vertex._data[key], obj), {});\n};\n\n/**\n *  This is like the regular vertex, but has database access.\n *  Depending on your use case, you would do different things.\n *  If your frontend has no direct GraphIT access, the use DataVertex\n *  If you are on the backend (or frontend with graph access) use the GraphVertex\n *  which can be saved.\n */\nexport default class GraphVertex extends Vertex {\n\n    /**\n     *  @ignore\n     */\n    constructor(data, context, guardSymbol) {\n        super(data);\n        if (guardSymbol !== $guard) {\n            throw new Error(`use 'createVertex', do not instaniate directly with 'new GraphVertex'`);\n        }\n        this._ctx = context;\n        this._db = context[this.type()];\n    }\n\n    /**\n     *  Save any changes back to the Graph\n     *\n     *  @param {object} options - any extra options to pass to the GraphIT connection\n     *  @return {Promise<GraphVertex>} - the new version of this Vertex\n     */\n    save(options = {}) {\n        if (this._clean && !options.force) {\n            return Promise.resolve(this);\n        }\n        //get changed data.\n        const data = getChangedData(this);\n        return this._db.update(this._id, data, options);\n    }\n\n    /**\n     *  Create a connection between this Vertex and another\n     *\n     *  The connection type is defined by the named Schema relationship.\n     *\n     *  @param {string} relation - the schema relationship to use\n     *  @param {string|Vertex} vertexOrId - the vertex or vertex id to connect to\n     *  @return {Promise<GraphVertex>} - the new version of this Vertexes\n     */\n    connect(relation, vertexOrId) {\n        return this._db.connect(relation, vertexOrId)\n            .then(refetchRelationData(this, relation));\n    }\n\n    /**\n     *  Remove a connection between this Vertex and another\n     *\n     *  The connection type is defined by the named Schema relationship.\n     *\n     *  @param {string} relation - the schema relationship to use\n     *  @param {string|Vertex} vertexOrId - the vertex or vertex id to sever connection to\n     *  @return {Promise<GraphVertex>} - the new version of this Vertexi\n     */\n    disconnect(relation, vertexOrId) {\n        return this._db.disconnect(relation, this._id, vertexOrId)\n            .then(refetchRelationData(this, relation));\n    }\n\n    /**\n     *  Fetch relationship info from the Graph (just counts)\n     *\n     *  @param {Array<string>} relations the array of relation names to fetch.\n     *  @param {object} options - any extra options to send to the GraphIT connection\n     *  @return {Promise<GraphVertex>} - the new version of this Vertex\n     */\n    fetchCount(relations, options = {}) {\n        return this._db.fetchCount(relations, options)(this)\n            .then(addRelationInfo(this));\n    }\n\n    /**\n     *  Fetch relationship info from the Graph (just Ids)\n     *\n     *  @param {Array<string>} relations the array of relation names to fetch.\n     *  @param {object} options - any extra options to send to the GraphIT connection\n     *  @return {Promise<GraphVertex>} - the new version of this Vertex\n     */\n    fetchIds(relations, options = {}) {\n        return this._db.fetchIds(relations, options)(this)\n            .then(addRelationInfo(this));\n    }\n\n    /**\n     *  Fetch relationship info from the Graph (full vertices)\n     *\n     *  @param {Array<string>} relations the array of relation names to fetch.\n     *  @param {object} options - any extra options to send to the GraphIT connection\n     *  @return {Promise<GraphVertex>} - the new version of this Vertex\n     */\n    fetchVertices(relations, options = {}) {\n        return this._db.fetchVertices(relations, options)(this)\n            .then(addRelationInfo(this));\n    }\n\n    /**\n     *  Delete this vertex from the Graph\n     *\n     *  @return {Promise<undefined>}\n     */\n    delete() {\n        return this._db.delete(this._id)\n            .then(() => {\n                this._ctx._cache.delete(this._id);\n            });\n    }\n\n    /**\n     *  Get the GraphVertices of entities bound by the given relation (if known)\n     *\n     *  Only available on a GraphVertex as we need Context\n     *\n     *  @param {string} relation - the name of the relation to query\n     *  @return {Array<GraphVertex>} - the array of GraphVertices\n     */\n    getVertices(relation) {\n        const ids = this._vertices[relation];\n        return (Array.isArray(ids) ? ids : [])\n            .map(id => this._ctx._cache.get(id))\n            .filter(Boolean);\n    }\n\n    /**\n     *  Ascertain whether we have write privileges on this node\n     *\n     *  @return {Promise<boolean>} - eventually returns whether we have write access or not.\n     */\n    canWrite() {\n        const randVal = (Math.random().toString(16) + Math.random().toString(16)).replace(/[0.]*/g, \"\") + Date.now();\n        const testKey = `/__jsGraphOrm_${randVal}`;\n        const rawConn = this._ctx.getConnection();\n        return rawConn\n            .update(this._id, { [testKey]: randVal })\n            .then(res => {\n                if (res[testKey] !== randVal) {\n                    throw new Error(\"value doesn't match - no write access\");\n                }\n                return rawConn.update(this._id, { [testKey]: null });\n            })\n            .then(() => true)\n            .catch(err => {\n                console.error(err);\n                return false;\n            });\n    }\n}\n\n//This refetches the minimum data possible about the relation\nconst refetchRelationData = (vertex, relation) => () => {\n    //find what we have on this and do the minimum possible.\n    const vtx = vertex.getVertices(relation).length;\n    const ids = vertex.getIds(relation).length;\n    const cts = vertex.getCount(relation);\n    if (vtx > 0 && vtx === ids && vtx === cts) {\n        return vertex.fetchVertices([relation], { refetch: true });\n    }\n    if (ids > 0 && ids === cts) {\n        return vertex.fetchIds([relation], { refetch: true });\n    }\n    if (cts > 0) {\n        return vertex.fetchCount([relation], { refetch: true });\n    }\n    //don't bother.\n    return vertex;\n};\n\nconst addRelationInfo = vertex => data => {\n    //data will be an object keyed on the relation and\n    //values will be either:\n    // - Array of Vertexes (getVertices) - but we only keep the id's\n    // - Array of strings (getIds)\n    // - an Integer (getCount)\n    const promises = Object.keys(data).map(relation => {\n        const value = data[relation];\n        if (Array.isArray(value)) {\n            //nodes or ids.\n            if (typeof value[0] === \"string\") {\n                // ids\n                return vertex.setIds(relation, value);\n            } else {\n                return vertex.setVertices(relation, value);\n            }\n        } else {\n            return vertex.setCount(relation, value);\n        }\n    });\n    return Promise.all(promises).then(res => res.length ? res[0] : vertex);\n};\n"
  },
  {
    "__docId__": 252,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "$guard",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~$guard",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 253,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createVertex",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~createVertex",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": "{createVertex}",
    "description": " Create a Context bound GraphVertex\n\n The GraphVertex constructor should not be used directly, rather through\n this function.\n\n It keeps the cache fresh, but clobbers object references\n so only a single object for each ID is created and updates\n create new versions.",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "the initial data (as with {@link Vertex})"
      },
      {
        "nullable": null,
        "types": [
          "Context"
        ],
        "spread": false,
        "optional": false,
        "name": "context",
        "description": "the context this vertex was retrieved in"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "GraphVertex"
      ],
      "spread": false,
      "description": "the vertex"
    },
    "generator": false
  },
  {
    "__docId__": 254,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "mergeRelations",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~mergeRelations",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": "{mergeRelations}",
    "description": "Used internally",
    "lineNumber": 34,
    "ignore": true,
    "params": [
      {
        "name": "oldVtx",
        "types": [
          "*"
        ]
      },
      {
        "name": "newVtx",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 255,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "getChangedData",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~getChangedData",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 256,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "GraphVertex",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~GraphVertex",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": "GraphVertex",
    "description": " This is like the regular vertex, but has database access.\n Depending on your use case, you would do different things.\n If your frontend has no direct GraphIT access, the use DataVertex\n If you are on the backend (or frontend with graph access) use the GraphVertex\n which can be saved.",
    "lineNumber": 55,
    "interface": false,
    "extends": [
      "src/vertex/index.js~Vertex"
    ]
  },
  {
    "__docId__": 257,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#constructor",
    "access": null,
    "description": "",
    "lineNumber": 60,
    "ignore": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "context",
        "types": [
          "*"
        ]
      },
      {
        "name": "guardSymbol",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 258,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_ctx",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#_ctx",
    "access": null,
    "description": null,
    "lineNumber": 65,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 259,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_db",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#_db",
    "access": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 260,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "save",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#save",
    "access": null,
    "description": " Save any changes back to the Graph",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "any extra options to pass to the GraphIT connection"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the new version of this Vertex"
    },
    "generator": false
  },
  {
    "__docId__": 261,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "connect",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#connect",
    "access": null,
    "description": " Create a connection between this Vertex and another\n\n The connection type is defined by the named Schema relationship.",
    "lineNumber": 93,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the schema relationship to use"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Vertex"
        ],
        "spread": false,
        "optional": false,
        "name": "vertexOrId",
        "description": "the vertex or vertex id to connect to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the new version of this Vertexes"
    },
    "generator": false
  },
  {
    "__docId__": 262,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "disconnect",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#disconnect",
    "access": null,
    "description": " Remove a connection between this Vertex and another\n\n The connection type is defined by the named Schema relationship.",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the schema relationship to use"
      },
      {
        "nullable": null,
        "types": [
          "string",
          "Vertex"
        ],
        "spread": false,
        "optional": false,
        "name": "vertexOrId",
        "description": "the vertex or vertex id to sever connection to"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the new version of this Vertexi"
    },
    "generator": false
  },
  {
    "__docId__": 263,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchCount",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#fetchCount",
    "access": null,
    "description": " Fetch relationship info from the Graph (just counts)",
    "lineNumber": 119,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the array of relation names to fetch."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "any extra options to send to the GraphIT connection"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the new version of this Vertex"
    },
    "generator": false
  },
  {
    "__docId__": 264,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchIds",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#fetchIds",
    "access": null,
    "description": " Fetch relationship info from the Graph (just Ids)",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the array of relation names to fetch."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "any extra options to send to the GraphIT connection"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the new version of this Vertex"
    },
    "generator": false
  },
  {
    "__docId__": 265,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fetchVertices",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#fetchVertices",
    "access": null,
    "description": " Fetch relationship info from the Graph (full vertices)",
    "lineNumber": 143,
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "relations",
        "description": "the array of relation names to fetch."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "any extra options to send to the GraphIT connection"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<GraphVertex>"
      ],
      "spread": false,
      "description": "the new version of this Vertex"
    },
    "generator": false
  },
  {
    "__docId__": 266,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "delete",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#delete",
    "access": null,
    "description": " Delete this vertex from the Graph",
    "lineNumber": 153,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<undefined>"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 267,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getVertices",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#getVertices",
    "access": null,
    "description": " Get the GraphVertices of entities bound by the given relation (if known)\n\n Only available on a GraphVertex as we need Context",
    "lineNumber": 168,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the name of the relation to query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<GraphVertex>"
      ],
      "spread": false,
      "description": "the array of GraphVertices"
    },
    "generator": false
  },
  {
    "__docId__": 268,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "canWrite",
    "memberof": "src/vertex/graph.js~GraphVertex",
    "longname": "src/vertex/graph.js~GraphVertex#canWrite",
    "access": null,
    "description": " Ascertain whether we have write privileges on this node",
    "lineNumber": 180,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise<boolean>"
      ],
      "spread": false,
      "description": "eventually returns whether we have write access or not."
    },
    "generator": false
  },
  {
    "__docId__": 269,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "refetchRelationData",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~refetchRelationData",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 201,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "addRelationInfo",
    "memberof": "src/vertex/graph.js",
    "longname": "src/vertex/graph.js~addRelationInfo",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex/graph",
    "importStyle": null,
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 271,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/vertex/index.js",
    "memberof": null,
    "longname": "src/vertex/index.js",
    "access": null,
    "description": null,
    "lineNumber": 5,
    "content": "/**\n *  The vertex class represents an instance of a vertex and it's relations to\n *  other vertices.\n */\nimport { clone } from \"../utils\";\n\n/**\n *  Check is an object is a vertex\n *\n *  @param {*} vertex - the thing which *could* be a {@link Vertex}\n *  @return {bool} - whether or not it is.\n */\nexport function isVertex(vertex) {\n    return vertex instanceof Vertex;\n}\n\n/**\n *  The base Vertex class representing a node in the graph.\n */\nexport default class Vertex {\n    /**\n     *  Create a vertex from the given data\n     *\n     *  @param {object} data - the object holding the data, should have at least `_id` and `_type`\n     *  @return {Vertex} - the Vertex\n     */\n    constructor(data) {\n        this._id = data._id;\n        this._isDeleted = \"_is-deleted\" in data ? data[\"_is-deleted\"] : false;\n\n        this._data = clone(data);\n\n        //relations\n        this._counts = {};\n        this._ids = {};\n        this._vertices = {};\n\n        //unmapped data.\n        //this should come in in a property called `_unmapped`\n        let _free = {};\n        if (\"_free\" in this._data) {\n            _free = this._data._free;\n            delete this._data._free;\n        }\n        this._free = _free;\n\n        this._clean = true;\n        this._before = {};\n    }\n\n    /**\n     *  Custom JSON pre-processing to get the relations and free props in order\n     *\n     *  @return {object}\n     */\n    toJSON() {\n        //ensure we dereference anything...\n        return Object.assign({\n            _rel: mergeRelations(this),\n            _free: clone(this._free)\n        }, clone(this._data));\n    }\n\n    /**\n     *  Return a plain object with the data in this one\n     *\n     *  @return {object}\n     */\n    plain() {\n        return this.toJSON();\n    }\n\n    /**\n     *  Get the type of this Vertex\n     *\n     *  @return {string} type = the type as named in the Schema\n     */\n    type() {\n        return this._data._type;\n    }\n\n    /**\n     *  Get a property value\n     *\n     *  @param {string} prop\n     */\n    get(prop) {\n        return this._data[prop];\n    }\n\n    /**\n     *  Get a free attributes.\n     *\n     *  These are generally not known at runtime, so we must\n     *  iterate ourselves\n     */\n    getFree() {\n        return this._free;\n    }\n\n    /**\n     *  Get the number of entities bound by the given relation (if known)\n     *\n     *  @param {string} relation - the name of the relation to query\n     *  @return {number} - the count\n     */\n    getCount(relation) {\n        return this._counts[relation] || 0;\n    }\n\n    /**\n     *  Get the ids of entities bound by the given relation (if known)\n     *\n     *  @param {string} relation - the name of the relation to query\n     *  @return {Array<string>} - the array of Ids\n     */\n    getIds(relation) {\n        return this._ids[relation] || [];\n    }\n\n    /**\n     *  Setters for mutating the data.\n     *\n     *  @param {string|object} prop - the string property or an object prop -> value.\n     *  @param {?any} value - the value to set (unless using the object version)\n     *  @return {Vertex} - this (i.e. chainable)\n     */\n    set(prop, value = null) {\n        if (this._isDeleted) {\n            throw new Error(\"cannot update deleted vertex\");\n        }\n        if (typeof prop !== \"string\") {\n            Object.keys(prop).forEach(key => this.set(key, prop[key]));\n            return this;\n        }\n        if (this._data[prop] === value) {\n            return this;\n        }\n        this._clean = false;\n        if (prop in this._before === false) {\n            //only set this the first time, i.e. to the value of the original data\n            this._before[prop] = this._data[prop];\n        }\n        this._data[prop] = value;\n        return this;\n    }\n\n    /**\n     *  Set the relationship data for a vertex (with related vertices)\n     *\n     *  This may seem superfluous because we don't set the nodes, just the ids.\n     *  but actually we don't want the interconnections.\n     *  the GraphVertex can pull the relations from cache, setting this here\n     *  with the different key is saying \"I fetched the nodes\".\n     *\n     *  Implies `setIds` and `setCount`\n     *\n     *  @param {string} relation - the relation identifier from the schema\n     *  @param {Array<Vertex>} nodes - the vertices to set.\n     *  @return {Vertex} - this (i.e. chainable)\n     */\n    setVertices(relation, nodes) {\n        const ids = nodes.map(n => n._id);\n        this._vertices[relation] = ids;\n        return this.setIds(relation, ids.slice());\n    }\n\n    /**\n     *  Set the relationship data for a vertex (with related vertex ids)\n     *\n     *  Implies `setCount`\n     *\n     *  @param {string} relation - the relation identifier from the schema\n     *  @param {Array<string>} ids - the vertex ids\n     *  @return {Vertex} - this (i.e. chainable)\n     */\n    setIds(relation, ids) {\n        this._ids[relation] = ids;\n        return this.setCount(relation, ids.length);\n    }\n\n    /**\n     *  Set the relationship data for a vertex (with related vertex counts)\n     *\n     *  @param {string} relation - the relation identifier from the schema\n     *  @param {number} count - the vertex count to set\n     *  @return {Vertex} - this (i.e. chainable)\n     */\n    setCount(relation, count) {\n        this._counts[relation] = count;\n        return this;\n    }\n}\n\n//pulls out ids and counts together.\nconst mergeRelations = vertex => {\n    return mapKeys(\n        vertex._counts,\n        addSuffix(\"Count\"),\n        mapKeys(vertex._ids, addSuffix(\"Ids\")));\n};\n\n//adds a suffix to a key\nconst addSuffix = suffix => key => key + suffix;\n\n//calls a function of each key of an object returning a new object\n// or the given one, with the new key names.\nconst mapKeys = (obj, fn, initial = {}) => Object.keys(obj).reduce((acc, key) => (acc[fn(key)] = obj[key], acc), initial);\n"
  },
  {
    "__docId__": 272,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "isVertex",
    "memberof": "src/vertex/index.js",
    "longname": "src/vertex/index.js~isVertex",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/vertex",
    "importStyle": "{isVertex}",
    "description": " Check is an object is a vertex",
    "lineNumber": 13,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "vertex",
        "description": "the thing which *could* be a {@link Vertex}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "bool"
      ],
      "spread": false,
      "description": "whether or not it is."
    },
    "generator": false
  },
  {
    "__docId__": 273,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "Vertex",
    "memberof": "src/vertex/index.js",
    "longname": "src/vertex/index.js~Vertex",
    "access": null,
    "export": true,
    "importPath": "hiro-graph-orm/lib/vertex",
    "importStyle": "Vertex",
    "description": " The base Vertex class representing a node in the graph.",
    "lineNumber": 20,
    "interface": false
  },
  {
    "__docId__": 274,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#constructor",
    "access": null,
    "description": " Create a vertex from the given data",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "the object holding the data, should have at least `_id` and `_type`"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vertex"
      ],
      "spread": false,
      "description": "the Vertex"
    },
    "generator": false
  },
  {
    "__docId__": 275,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_id",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_id",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 276,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_isDeleted",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_isDeleted",
    "access": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 277,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_data",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_data",
    "access": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 278,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_counts",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_counts",
    "access": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_ids",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_ids",
    "access": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_vertices",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_vertices",
    "access": null,
    "description": null,
    "lineNumber": 36,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_free",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_free",
    "access": null,
    "description": null,
    "lineNumber": 45,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_clean",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_clean",
    "access": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 283,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_before",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_before",
    "access": null,
    "description": null,
    "lineNumber": 48,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "toJSON",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#toJSON",
    "access": null,
    "description": " Custom JSON pre-processing to get the relations and free props in order",
    "lineNumber": 56,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 285,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "plain",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#plain",
    "access": null,
    "description": " Return a plain object with the data in this one",
    "lineNumber": 69,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 286,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "type",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#type",
    "access": null,
    "description": " Get the type of this Vertex",
    "lineNumber": 78,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "type = the type as named in the Schema"
    },
    "generator": false
  },
  {
    "__docId__": 287,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "get",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#get",
    "access": null,
    "description": " Get a property value",
    "lineNumber": 87,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": ""
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 288,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getFree",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#getFree",
    "access": null,
    "description": " Get a free attributes.\n\n These are generally not known at runtime, so we must\n iterate ourselves",
    "lineNumber": 97,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 289,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getCount",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#getCount",
    "access": null,
    "description": " Get the number of entities bound by the given relation (if known)",
    "lineNumber": 107,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the name of the relation to query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "the count"
    },
    "generator": false
  },
  {
    "__docId__": 290,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getIds",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#getIds",
    "access": null,
    "description": " Get the ids of entities bound by the given relation (if known)",
    "lineNumber": 117,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the name of the relation to query"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Array<string>"
      ],
      "spread": false,
      "description": "the array of Ids"
    },
    "generator": false
  },
  {
    "__docId__": 291,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "set",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#set",
    "access": null,
    "description": " Setters for mutating the data.",
    "lineNumber": 128,
    "params": [
      {
        "nullable": null,
        "types": [
          "string",
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "prop",
        "description": "the string property or an object prop -> value."
      },
      {
        "nullable": true,
        "types": [
          "any"
        ],
        "spread": false,
        "optional": false,
        "name": "value",
        "description": "the value to set (unless using the object version)"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vertex"
      ],
      "spread": false,
      "description": "this (i.e. chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 292,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "_clean",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#_clean",
    "access": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 293,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setVertices",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#setVertices",
    "access": null,
    "description": " Set the relationship data for a vertex (with related vertices)\n\n This may seem superfluous because we don't set the nodes, just the ids.\n but actually we don't want the interconnections.\n the GraphVertex can pull the relations from cache, setting this here\n with the different key is saying \"I fetched the nodes\".\n\n Implies `setIds` and `setCount`",
    "lineNumber": 162,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the relation identifier from the schema"
      },
      {
        "nullable": null,
        "types": [
          "Array<Vertex>"
        ],
        "spread": false,
        "optional": false,
        "name": "nodes",
        "description": "the vertices to set."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vertex"
      ],
      "spread": false,
      "description": "this (i.e. chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 294,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setIds",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#setIds",
    "access": null,
    "description": " Set the relationship data for a vertex (with related vertex ids)\n\n Implies `setCount`",
    "lineNumber": 177,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the relation identifier from the schema"
      },
      {
        "nullable": null,
        "types": [
          "Array<string>"
        ],
        "spread": false,
        "optional": false,
        "name": "ids",
        "description": "the vertex ids"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vertex"
      ],
      "spread": false,
      "description": "this (i.e. chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 295,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "setCount",
    "memberof": "src/vertex/index.js~Vertex",
    "longname": "src/vertex/index.js~Vertex#setCount",
    "access": null,
    "description": " Set the relationship data for a vertex (with related vertex counts)",
    "lineNumber": 189,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "relation",
        "description": "the relation identifier from the schema"
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "count",
        "description": "the vertex count to set"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Vertex"
      ],
      "spread": false,
      "description": "this (i.e. chainable)"
    },
    "generator": false
  },
  {
    "__docId__": 296,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mergeRelations",
    "memberof": "src/vertex/index.js",
    "longname": "src/vertex/index.js~mergeRelations",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex",
    "importStyle": null,
    "description": null,
    "lineNumber": 196,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 297,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "addSuffix",
    "memberof": "src/vertex/index.js",
    "longname": "src/vertex/index.js~addSuffix",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex",
    "importStyle": null,
    "description": null,
    "lineNumber": 204,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 298,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "mapKeys",
    "memberof": "src/vertex/index.js",
    "longname": "src/vertex/index.js~mapKeys",
    "access": null,
    "export": false,
    "importPath": "hiro-graph-orm/lib/vertex",
    "importStyle": null,
    "description": null,
    "lineNumber": 208,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 300,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 301,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 302,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 303,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 304,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 305,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 306,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 307,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 308,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 309,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 310,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 311,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 312,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 313,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 314,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 315,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 316,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 317,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 318,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 319,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 320,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 321,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 322,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 323,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 324,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 325,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 326,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 327,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 328,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 329,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 330,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 331,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 332,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 333,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 334,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 335,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 336,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 337,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 338,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 339,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 340,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 341,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 342,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 343,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 344,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 345,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 346,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 348,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 349,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 350,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 351,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 352,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 353,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 354,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 355,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": "",
    "builtinExternal": true
  }
]